extsel.cpp 1: 
extsel.cpp 2: 
extsel.cpp 3: 
extsel.cpp 4: 
extsel.cpp 5: 
\BC31\INCLUDE\stdlib.h 1: 
\BC31\INCLUDE\stdlib.h 2: 
\BC31\INCLUDE\stdlib.h 3: 
\BC31\INCLUDE\stdlib.h 4: 
\BC31\INCLUDE\stdlib.h 5: 
\BC31\INCLUDE\stdlib.h 6: 
\BC31\INCLUDE\stdlib.h 7: 
\BC31\INCLUDE\stdlib.h 8: 
\BC31\INCLUDE\stdlib.h 9: 
\BC31\INCLUDE\stdlib.h 10: 
\BC31\INCLUDE\stdlib.h 11: 
\BC31\INCLUDE\stdlib.h 12: 
\BC31\INCLUDE\stdlib.h 13: 
\BC31\INCLUDE\_defs.h 1: 
\BC31\INCLUDE\_defs.h 2: 
\BC31\INCLUDE\_defs.h 3: 
\BC31\INCLUDE\_defs.h 4: 
\BC31\INCLUDE\_defs.h 5: 
\BC31\INCLUDE\_defs.h 6: 
\BC31\INCLUDE\_defs.h 7: 
\BC31\INCLUDE\_defs.h 8: 
\BC31\INCLUDE\_defs.h 9: 
\BC31\INCLUDE\_defs.h 10: 
\BC31\INCLUDE\_defs.h 11: 
\BC31\INCLUDE\_defs.h 12: 
\BC31\INCLUDE\_defs.h 13: 
\BC31\INCLUDE\_defs.h 14: 
\BC31\INCLUDE\_defs.h 15: 
\BC31\INCLUDE\_defs.h 16: 
\BC31\INCLUDE\_defs.h 17: 
\BC31\INCLUDE\_defs.h 18: 
\BC31\INCLUDE\_defs.h 19: 
\BC31\INCLUDE\_defs.h 20: 
\BC31\INCLUDE\_defs.h 21: 
\BC31\INCLUDE\_defs.h 22: 
\BC31\INCLUDE\_defs.h 23: 
\BC31\INCLUDE\_defs.h 24: 
\BC31\INCLUDE\_defs.h 25: 
\BC31\INCLUDE\_defs.h 26: 
\BC31\INCLUDE\_defs.h 27: 
\BC31\INCLUDE\_defs.h 28: 
\BC31\INCLUDE\_defs.h 29: 
\BC31\INCLUDE\_defs.h 30: 
\BC31\INCLUDE\_defs.h 31: 
\BC31\INCLUDE\_defs.h 32: 
\BC31\INCLUDE\_defs.h 33: 
\BC31\INCLUDE\_defs.h 34: 
\BC31\INCLUDE\_defs.h 35: 
\BC31\INCLUDE\_defs.h 36: 
\BC31\INCLUDE\_defs.h 37: 
\BC31\INCLUDE\_defs.h 38: 
\BC31\INCLUDE\_defs.h 39: 
\BC31\INCLUDE\_defs.h 40: 
\BC31\INCLUDE\_defs.h 41: 
\BC31\INCLUDE\_defs.h 42: 
\BC31\INCLUDE\_defs.h 43: 
\BC31\INCLUDE\_defs.h 44: 
\BC31\INCLUDE\_defs.h 45: 
\BC31\INCLUDE\_defs.h 46: 
\BC31\INCLUDE\_defs.h 47: 
\BC31\INCLUDE\_defs.h 48: 
\BC31\INCLUDE\_defs.h 49: 
\BC31\INCLUDE\_defs.h 50: 
\BC31\INCLUDE\_defs.h 51: 
\BC31\INCLUDE\_defs.h 52: 
\BC31\INCLUDE\_defs.h 53: 
\BC31\INCLUDE\_defs.h 54: 
\BC31\INCLUDE\_defs.h 55: 
\BC31\INCLUDE\_defs.h 56: 
\BC31\INCLUDE\_defs.h 57: 
\BC31\INCLUDE\_defs.h 58: 
\BC31\INCLUDE\_defs.h 59: 
\BC31\INCLUDE\_defs.h 60: 
\BC31\INCLUDE\_defs.h 61: 
\BC31\INCLUDE\_defs.h 62: 
\BC31\INCLUDE\_defs.h 63: 
\BC31\INCLUDE\_defs.h 64: 
\BC31\INCLUDE\_defs.h 65: 
\BC31\INCLUDE\_defs.h 66: 
\BC31\INCLUDE\_defs.h 67: 
\BC31\INCLUDE\_defs.h 68: 
\BC31\INCLUDE\_defs.h 69:   
\BC31\INCLUDE\_defs.h 70: 
\BC31\INCLUDE\_defs.h 71: 
\BC31\INCLUDE\_defs.h 72: 
\BC31\INCLUDE\_defs.h 73: 
\BC31\INCLUDE\_defs.h 74:     
\BC31\INCLUDE\_defs.h 75: 
\BC31\INCLUDE\_defs.h 76: 
\BC31\INCLUDE\_defs.h 77: 
\BC31\INCLUDE\_defs.h 78: 
\BC31\INCLUDE\_defs.h 79: 
\BC31\INCLUDE\_defs.h 80: 
\BC31\INCLUDE\_defs.h 81: 
\BC31\INCLUDE\_defs.h 82: 
\BC31\INCLUDE\_defs.h 83: 
\BC31\INCLUDE\_defs.h 84: 
\BC31\INCLUDE\_defs.h 85: 
\BC31\INCLUDE\_defs.h 86: 
\BC31\INCLUDE\_defs.h 87: 
\BC31\INCLUDE\_defs.h 88: 
\BC31\INCLUDE\_defs.h 89: 
\BC31\INCLUDE\_defs.h 90: 
\BC31\INCLUDE\_defs.h 91: 
\BC31\INCLUDE\_defs.h 92: 
\BC31\INCLUDE\_defs.h 93: 
\BC31\INCLUDE\_defs.h 94: 
\BC31\INCLUDE\_defs.h 95: 
\BC31\INCLUDE\_defs.h 96: 
\BC31\INCLUDE\_defs.h 97: 
\BC31\INCLUDE\_defs.h 98: 
\BC31\INCLUDE\_defs.h 99: 
\BC31\INCLUDE\_defs.h 100: 
\BC31\INCLUDE\_defs.h 101: 
\BC31\INCLUDE\_defs.h 102: 
\BC31\INCLUDE\_defs.h 103: 
\BC31\INCLUDE\_defs.h 104: 
\BC31\INCLUDE\_defs.h 105: 
\BC31\INCLUDE\_defs.h 106: 
\BC31\INCLUDE\stdlib.h 14: 
\BC31\INCLUDE\stdlib.h 15: 
\BC31\INCLUDE\stdlib.h 16: 
\BC31\INCLUDE\stdlib.h 17: 
\BC31\INCLUDE\_null.h 1: 
\BC31\INCLUDE\_null.h 2: 
\BC31\INCLUDE\_null.h 3: 
\BC31\INCLUDE\_null.h 4: 
\BC31\INCLUDE\_null.h 5: 
\BC31\INCLUDE\_null.h 6: 
\BC31\INCLUDE\_null.h 7: 
\BC31\INCLUDE\_null.h 8: 
\BC31\INCLUDE\_null.h 9: 
\BC31\INCLUDE\_null.h 10:     
\BC31\INCLUDE\_null.h 11: 
\BC31\INCLUDE\_null.h 12: 
\BC31\INCLUDE\_null.h 13: 
\BC31\INCLUDE\_null.h 14: 
\BC31\INCLUDE\_null.h 15: 
\BC31\INCLUDE\_null.h 16: 
\BC31\INCLUDE\_null.h 17: 
\BC31\INCLUDE\stdlib.h 18: 
\BC31\INCLUDE\stdlib.h 19: 
\BC31\INCLUDE\stdlib.h 20: 
\BC31\INCLUDE\stdlib.h 21: 
\BC31\INCLUDE\stdlib.h 22: typedef unsigned size_t;
\BC31\INCLUDE\stdlib.h 23: 
\BC31\INCLUDE\stdlib.h 24: 
\BC31\INCLUDE\stdlib.h 25: 
\BC31\INCLUDE\stdlib.h 26: 
\BC31\INCLUDE\stdlib.h 27: typedef struct {
\BC31\INCLUDE\stdlib.h 28: int     quot;
\BC31\INCLUDE\stdlib.h 29: int     rem;
\BC31\INCLUDE\stdlib.h 30: } div_t;
\BC31\INCLUDE\stdlib.h 31: 
\BC31\INCLUDE\stdlib.h 32: 
\BC31\INCLUDE\stdlib.h 33: 
\BC31\INCLUDE\stdlib.h 34: 
\BC31\INCLUDE\stdlib.h 35: typedef struct {
\BC31\INCLUDE\stdlib.h 36: long    quot;
\BC31\INCLUDE\stdlib.h 37: long    rem;
\BC31\INCLUDE\stdlib.h 38: } ldiv_t;
\BC31\INCLUDE\stdlib.h 39: 
\BC31\INCLUDE\stdlib.h 40: 
\BC31\INCLUDE\stdlib.h 41: 
\BC31\INCLUDE\stdlib.h 42: 
\BC31\INCLUDE\stdlib.h 43: typedef char wchar_t;
\BC31\INCLUDE\stdlib.h 44: 
\BC31\INCLUDE\stdlib.h 45: 
\BC31\INCLUDE\stdlib.h 46: 
\BC31\INCLUDE\stdlib.h 47: 
\BC31\INCLUDE\stdlib.h 48: typedef void __cdecl (* atexit_t)(void);
\BC31\INCLUDE\stdlib.h 49: 
\BC31\INCLUDE\stdlib.h 50: 
\BC31\INCLUDE\stdlib.h 51: 
\BC31\INCLUDE\stdlib.h 52: 
\BC31\INCLUDE\stdlib.h 53: 
\BC31\INCLUDE\stdlib.h 54: 
\BC31\INCLUDE\stdlib.h 55: 
\BC31\INCLUDE\stdlib.h 56: 
\BC31\INCLUDE\stdlib.h 57: 
\BC31\INCLUDE\stdlib.h 58: 
\BC31\INCLUDE\stdlib.h 59: 
\BC31\INCLUDE\stdlib.h 60: extern "C" {
\BC31\INCLUDE\stdlib.h 61: 
\BC31\INCLUDE\stdlib.h 62: 
\BC31\INCLUDE\stdlib.h 63: void        __cdecl abort(void);
\BC31\INCLUDE\stdlib.h 64: int         __cdecl __abs__(int);
\BC31\INCLUDE\stdlib.h 65: 
\BC31\INCLUDE\stdlib.h 66: inline int __cdecl  abs(int __x) { return __abs__(__x); }
\BC31\INCLUDE\stdlib.h 67: 
\BC31\INCLUDE\stdlib.h 68: 
\BC31\INCLUDE\stdlib.h 69: 
\BC31\INCLUDE\stdlib.h 70: 
\BC31\INCLUDE\stdlib.h 71: int         __cdecl atexit(void (__cdecl *__func)(void));
\BC31\INCLUDE\stdlib.h 72: double      __cdecl atof(const char  *__s);
\BC31\INCLUDE\stdlib.h 73: int         __cdecl atoi(const char  *__s);
\BC31\INCLUDE\stdlib.h 74: long        __cdecl atol(const char  *__s);
\BC31\INCLUDE\stdlib.h 75: void  * __cdecl bsearch(const void  *__key, const void  *__base,
\BC31\INCLUDE\stdlib.h 76: size_t __nelem, size_t __width,
\BC31\INCLUDE\stdlib.h 77: int (__cdecl *fcmp)(const void  *,
\BC31\INCLUDE\stdlib.h 78: const void  *));
\BC31\INCLUDE\stdlib.h 79: void  * __cdecl calloc(size_t __nitems, size_t __size);
\BC31\INCLUDE\stdlib.h 80: div_t       __cdecl div(int __numer, int __denom);
\BC31\INCLUDE\stdlib.h 81: void        __cdecl exit(int __status);
\BC31\INCLUDE\stdlib.h 82: void        __cdecl free(void  *__block);
\BC31\INCLUDE\stdlib.h 83: char  * __cdecl getenv(const char  *__name);
\BC31\INCLUDE\stdlib.h 84: long        __cdecl labs(long __x);
\BC31\INCLUDE\stdlib.h 85: ldiv_t      __cdecl ldiv(long __numer, long __denom);
\BC31\INCLUDE\stdlib.h 86: void  * __cdecl malloc(size_t __size);
\BC31\INCLUDE\stdlib.h 87: int         __cdecl mblen(const char  *__s, size_t __n);
\BC31\INCLUDE\stdlib.h 88: size_t      __cdecl mbstowcs(wchar_t  *__pwcs, const char  *__s,
\BC31\INCLUDE\stdlib.h 89: size_t __n);
\BC31\INCLUDE\stdlib.h 90: int     __cdecl  mbtowc(wchar_t  *__pwc, const char  *__s, size_t __n);
\BC31\INCLUDE\stdlib.h 91: void    __cdecl  qsort(void  *__base, size_t __nelem, size_t __width,
\BC31\INCLUDE\stdlib.h 92: int __cdecl (* __fcmp)(const void  *, const void  *));
\BC31\INCLUDE\stdlib.h 93: int     __cdecl rand(void);
\BC31\INCLUDE\stdlib.h 94: void  *__cdecl realloc(void  *__block, size_t __size);
\BC31\INCLUDE\stdlib.h 95: void    __cdecl srand(unsigned __seed);
\BC31\INCLUDE\stdlib.h 96: double  __cdecl strtod(const char  *__s, char  * *__endptr);
\BC31\INCLUDE\stdlib.h 97: long    __cdecl  strtol(const char  *__s, char  * *__endptr,
\BC31\INCLUDE\stdlib.h 98: int __radix);
\BC31\INCLUDE\stdlib.h 99: long double __cdecl _strtold(const char  *__s, char  * *__endptr);
\BC31\INCLUDE\stdlib.h 100: unsigned long __cdecl  strtoul(const char  *__s, char  * *__endptr,
\BC31\INCLUDE\stdlib.h 101: int __radix);
\BC31\INCLUDE\stdlib.h 102: int     __cdecl  system(const char  *__command);
\BC31\INCLUDE\stdlib.h 103: size_t  __cdecl  wcstombs(char  *__s, const wchar_t  *__pwcs,
\BC31\INCLUDE\stdlib.h 104: size_t __n);
\BC31\INCLUDE\stdlib.h 105: int     __cdecl  wctomb(char  *__s, wchar_t __wc);
\BC31\INCLUDE\stdlib.h 106: 
\BC31\INCLUDE\stdlib.h 107: 
\BC31\INCLUDE\stdlib.h 108: }
\BC31\INCLUDE\stdlib.h 109: 
\BC31\INCLUDE\stdlib.h 110: 
\BC31\INCLUDE\stdlib.h 111: 
\BC31\INCLUDE\stdlib.h 112: 
\BC31\INCLUDE\stdlib.h 113: 
\BC31\INCLUDE\stdlib.h 114: 
\BC31\INCLUDE\stdlib.h 115: 
\BC31\INCLUDE\stdlib.h 116: 
\BC31\INCLUDE\stdlib.h 117: 
\BC31\INCLUDE\stdlib.h 118: 
\BC31\INCLUDE\stdlib.h 119: 
\BC31\INCLUDE\stdlib.h 120: 
\BC31\INCLUDE\stdlib.h 121: 
\BC31\INCLUDE\stdlib.h 122: 
\BC31\INCLUDE\stdlib.h 123: 
\BC31\INCLUDE\stdlib.h 124: 
\BC31\INCLUDE\stdlib.h 125: 
\BC31\INCLUDE\stdlib.h 126: 
\BC31\INCLUDE\stdlib.h 127: 
\BC31\INCLUDE\stdlib.h 128: 
\BC31\INCLUDE\stdlib.h 129: 
\BC31\INCLUDE\stdlib.h 130: 
\BC31\INCLUDE\stdlib.h 131: 
\BC31\INCLUDE\stdlib.h 132: 
\BC31\INCLUDE\stdlib.h 133: extern  int   __cdecl _doserrno;
\BC31\INCLUDE\stdlib.h 134: extern  int   __cdecl errno;
\BC31\INCLUDE\stdlib.h 135: 
\BC31\INCLUDE\stdlib.h 136: 
\BC31\INCLUDE\stdlib.h 137: 
\BC31\INCLUDE\stdlib.h 138: 
\BC31\INCLUDE\stdlib.h 139: 
\BC31\INCLUDE\stdlib.h 140: 
\BC31\INCLUDE\stdlib.h 141: 
\BC31\INCLUDE\stdlib.h 142: 
\BC31\INCLUDE\stdlib.h 143: 
\BC31\INCLUDE\stdlib.h 144: 
\BC31\INCLUDE\stdlib.h 145: 
\BC31\INCLUDE\stdlib.h 146: 
\BC31\INCLUDE\stdlib.h 147: extern  unsigned        __cdecl _psp;
\BC31\INCLUDE\stdlib.h 148: 
\BC31\INCLUDE\stdlib.h 149: extern  char          **__cdecl environ;
\BC31\INCLUDE\stdlib.h 150: extern  int             __cdecl _fmode;
\BC31\INCLUDE\stdlib.h 151: extern  unsigned char   __cdecl _osmajor;
\BC31\INCLUDE\stdlib.h 152: extern  unsigned char   __cdecl _osminor;
\BC31\INCLUDE\stdlib.h 153: extern  unsigned int    __cdecl _version;
\BC31\INCLUDE\stdlib.h 154: 
\BC31\INCLUDE\stdlib.h 155: 
\BC31\INCLUDE\stdlib.h 156: 
\BC31\INCLUDE\stdlib.h 157: 
\BC31\INCLUDE\stdlib.h 158: 
\BC31\INCLUDE\stdlib.h 159: 
\BC31\INCLUDE\stdlib.h 160: 
\BC31\INCLUDE\stdlib.h 161: 
\BC31\INCLUDE\stdlib.h 162: 
\BC31\INCLUDE\stdlib.h 163: 
\BC31\INCLUDE\stdlib.h 164: 
\BC31\INCLUDE\stdlib.h 165: 
\BC31\INCLUDE\stdlib.h 166: 
\BC31\INCLUDE\stdlib.h 167: 
\BC31\INCLUDE\stdlib.h 168: 
\BC31\INCLUDE\stdlib.h 169: 
\BC31\INCLUDE\stdlib.h 170: 
\BC31\INCLUDE\stdlib.h 171: extern  char            *__cdecl sys_errlist[];
\BC31\INCLUDE\stdlib.h 172: extern  int             __cdecl sys_nerr;
\BC31\INCLUDE\stdlib.h 173: 
\BC31\INCLUDE\stdlib.h 174: 
\BC31\INCLUDE\stdlib.h 175: 
\BC31\INCLUDE\stdlib.h 176: 
\BC31\INCLUDE\stdlib.h 177: 
\BC31\INCLUDE\stdlib.h 178: 
\BC31\INCLUDE\stdlib.h 179: 
\BC31\INCLUDE\stdlib.h 180: 
\BC31\INCLUDE\stdlib.h 181: 
\BC31\INCLUDE\stdlib.h 182: 
\BC31\INCLUDE\stdlib.h 183: 
\BC31\INCLUDE\stdlib.h 184: 
\BC31\INCLUDE\stdlib.h 185: inline int __cdecl random(int __num)
\BC31\INCLUDE\stdlib.h 186: { return(int)(((long)rand()*__num)/(0x7FFFU+1)); }
\BC31\INCLUDE\stdlib.h 187: 
\BC31\INCLUDE\stdlib.h 188: extern "C" long __cdecl  time(long  *);
\BC31\INCLUDE\stdlib.h 189: inline void __cdecl randomize(void) { srand((unsigned) time(0)); }
\BC31\INCLUDE\stdlib.h 190: inline int  __cdecl atoi(const char  *__s) { return (int) atol(__s); }
\BC31\INCLUDE\stdlib.h 191: 
\BC31\INCLUDE\stdlib.h 192: 
\BC31\INCLUDE\stdlib.h 193: 
\BC31\INCLUDE\stdlib.h 194: 
\BC31\INCLUDE\stdlib.h 195: 
\BC31\INCLUDE\stdlib.h 196: 
\BC31\INCLUDE\stdlib.h 197: 
\BC31\INCLUDE\stdlib.h 198: 
\BC31\INCLUDE\stdlib.h 199: 
\BC31\INCLUDE\stdlib.h 200: extern "C" {
\BC31\INCLUDE\stdlib.h 201: 
\BC31\INCLUDE\stdlib.h 202: 
\BC31\INCLUDE\stdlib.h 203: long double __cdecl _atold(const char  *__s);
\BC31\INCLUDE\stdlib.h 204: char    *__cdecl ecvt(double __value, int __ndig, int  *__dec,
\BC31\INCLUDE\stdlib.h 205: int  *__sign);
\BC31\INCLUDE\stdlib.h 206: void    __cdecl _exit(int __status);
\BC31\INCLUDE\stdlib.h 207: char    *__cdecl fcvt(double __value, int __ndig, int  *__dec,
\BC31\INCLUDE\stdlib.h 208: int  *__sign);
\BC31\INCLUDE\stdlib.h 209: char  * __cdecl  _fullpath( char  *__buf,
\BC31\INCLUDE\stdlib.h 210: const char  *__path,
\BC31\INCLUDE\stdlib.h 211: size_t __maxlen );
\BC31\INCLUDE\stdlib.h 212: char    *__cdecl gcvt(double __value, int __ndec, char  *__buf);
\BC31\INCLUDE\stdlib.h 213: char    *__cdecl  itoa(int __value, char  *__string, int __radix);
\BC31\INCLUDE\stdlib.h 214: void    *__cdecl  lfind(const void  *__key, const void  *__base,
\BC31\INCLUDE\stdlib.h 215: size_t  *__num, size_t __width,
\BC31\INCLUDE\stdlib.h 216: int __cdecl(* __fcmp)(const void  *, const void  *));
\BC31\INCLUDE\stdlib.h 217: 
\BC31\INCLUDE\stdlib.h 218: unsigned long __cdecl _lrotl(unsigned long __val, int __count);
\BC31\INCLUDE\stdlib.h 219: unsigned long __cdecl _lrotr(unsigned long __val, int __count);
\BC31\INCLUDE\stdlib.h 220: 
\BC31\INCLUDE\stdlib.h 221: void    *__cdecl  lsearch(const void  *__key, void  *__base,
\BC31\INCLUDE\stdlib.h 222: size_t  *__num, size_t __width,
\BC31\INCLUDE\stdlib.h 223: int __cdecl(* __fcmp)(const void  *, const void  *));
\BC31\INCLUDE\stdlib.h 224: char  * __cdecl  ltoa(long __value, char  *__string, int __radix);
\BC31\INCLUDE\stdlib.h 225: void __cdecl  _makepath( char  *__path,
\BC31\INCLUDE\stdlib.h 226: const char  *__drive,
\BC31\INCLUDE\stdlib.h 227: const char  *__dir,
\BC31\INCLUDE\stdlib.h 228: const char  *__name,
\BC31\INCLUDE\stdlib.h 229: const char  *__ext );
\BC31\INCLUDE\stdlib.h 230: int     __cdecl  putenv(const char  *__name);
\BC31\INCLUDE\stdlib.h 231: 
\BC31\INCLUDE\stdlib.h 232: unsigned    __cdecl _rotl(unsigned __value, int __count);
\BC31\INCLUDE\stdlib.h 233: unsigned    __cdecl _rotr(unsigned __value, int __count);
\BC31\INCLUDE\stdlib.h 234: 
\BC31\INCLUDE\stdlib.h 235: unsigned    __cdecl __rotl__(unsigned __value, int __count);     
\BC31\INCLUDE\stdlib.h 236: unsigned    __cdecl __rotr__(unsigned __value, int __count);     
\BC31\INCLUDE\stdlib.h 237: 
\BC31\INCLUDE\stdlib.h 238: void        __cdecl _searchenv(const char  *__file,
\BC31\INCLUDE\stdlib.h 239: const char  *__varname,
\BC31\INCLUDE\stdlib.h 240: char  *__pathname);
\BC31\INCLUDE\stdlib.h 241: void        __cdecl _searchstr(const char  *__file,
\BC31\INCLUDE\stdlib.h 242: const char  *__ipath,
\BC31\INCLUDE\stdlib.h 243: char  *__pathname);
\BC31\INCLUDE\stdlib.h 244: void __cdecl  _splitpath( const char  *__path,
\BC31\INCLUDE\stdlib.h 245: char  *__drive,
\BC31\INCLUDE\stdlib.h 246: char  *__dir,
\BC31\INCLUDE\stdlib.h 247: char  *__name,
\BC31\INCLUDE\stdlib.h 248: char  *__ext );
\BC31\INCLUDE\stdlib.h 249: void    __cdecl  swab(char  *__from, char  *__to, int __nbytes);
\BC31\INCLUDE\stdlib.h 250: char  *__cdecl  ultoa(unsigned long __value, char  *__string,
\BC31\INCLUDE\stdlib.h 251: int __radix);
\BC31\INCLUDE\stdlib.h 252: 
\BC31\INCLUDE\stdlib.h 253: 
\BC31\INCLUDE\stdlib.h 254: 
\BC31\INCLUDE\stdlib.h 255: }
\BC31\INCLUDE\stdlib.h 256: 
\BC31\INCLUDE\stdlib.h 257: 
\BC31\INCLUDE\stdlib.h 258: 
\BC31\INCLUDE\stdlib.h 259: 
\BC31\INCLUDE\stdlib.h 260: 
\BC31\INCLUDE\stdlib.h 261: 
\BC31\INCLUDE\stdlib.h 262: 
\BC31\INCLUDE\stdlib.h 263: 
\BC31\INCLUDE\stdlib.h 264: 
\BC31\INCLUDE\stdlib.h 265: 
\BC31\INCLUDE\stdlib.h 266: 
\BC31\INCLUDE\stdlib.h 267: 
extsel.cpp 6: 
\BC31\INCLUDE\string.h 1: 
\BC31\INCLUDE\string.h 2: 
\BC31\INCLUDE\string.h 3: 
\BC31\INCLUDE\string.h 4: 
\BC31\INCLUDE\string.h 5: 
\BC31\INCLUDE\string.h 6: 
\BC31\INCLUDE\string.h 7: 
\BC31\INCLUDE\string.h 8: 
\BC31\INCLUDE\string.h 9: 
\BC31\INCLUDE\string.h 10: 
\BC31\INCLUDE\string.h 11: 
\BC31\INCLUDE\string.h 12: 
\BC31\INCLUDE\string.h 13: 
\BC31\INCLUDE\string.h 14: 
\BC31\INCLUDE\string.h 15: 
\BC31\INCLUDE\string.h 16: 
\BC31\INCLUDE\string.h 17: 
\BC31\INCLUDE\string.h 18: 
\BC31\INCLUDE\string.h 19: 
\BC31\INCLUDE\string.h 20: 
\BC31\INCLUDE\string.h 21: 
\BC31\INCLUDE\string.h 22: 
\BC31\INCLUDE\string.h 23: 
\BC31\INCLUDE\string.h 24: 
\BC31\INCLUDE\string.h 25: 
\BC31\INCLUDE\string.h 26: extern "C" {
\BC31\INCLUDE\string.h 27: 
\BC31\INCLUDE\string.h 28: void  * __cdecl  memchr  (const void  *__s, int __c, size_t __n);
\BC31\INCLUDE\string.h 29: int         __cdecl  memcmp(const void  *__s1,
\BC31\INCLUDE\string.h 30: const void  *__s2, size_t __n);
\BC31\INCLUDE\string.h 31: void  * __cdecl  memcpy(void  *__dest, const void  *__src,
\BC31\INCLUDE\string.h 32: size_t __n);
\BC31\INCLUDE\string.h 33: void  * __cdecl  memmove(void  *__dest, const void  *__src,
\BC31\INCLUDE\string.h 34: size_t __n);
\BC31\INCLUDE\string.h 35: void  * __cdecl  memset(void  *__s, int __c, size_t __n);
\BC31\INCLUDE\string.h 36: char  * __cdecl  strcat(char  *__dest, const char  *__src);
\BC31\INCLUDE\string.h 37: char  * __cdecl  strchr(const char  *__s, int __c);
\BC31\INCLUDE\string.h 38: int         __cdecl  strcmp(const char  *__s1, const char  *__s2);
\BC31\INCLUDE\string.h 39: int         __cdecl strcoll(const char  *__s1, const char  *__s2);
\BC31\INCLUDE\string.h 40: char  * __cdecl  strcpy(char  *__dest, const char  *__src);
\BC31\INCLUDE\string.h 41: size_t      __cdecl  strcspn(const char  *__s1, const char  *__s2);
\BC31\INCLUDE\string.h 42: char  * __cdecl  strerror(int __errnum);
\BC31\INCLUDE\string.h 43: size_t      __cdecl  strlen(const char  *__s);
\BC31\INCLUDE\string.h 44: char  * __cdecl  strncat(char  *__dest, const char  *__src,
\BC31\INCLUDE\string.h 45: size_t __maxlen);
\BC31\INCLUDE\string.h 46: int         __cdecl  strncmp(const char  *__s1, const char  *__s2,
\BC31\INCLUDE\string.h 47: size_t __maxlen);
\BC31\INCLUDE\string.h 48: char  * __cdecl  strncpy(char  *__dest, const char  *__src,
\BC31\INCLUDE\string.h 49: size_t __maxlen);
\BC31\INCLUDE\string.h 50: char  * __cdecl  strpbrk(const char  *__s1, const char  *__s2);
\BC31\INCLUDE\string.h 51: char  * __cdecl  strrchr(const char  *__s, int __c);
\BC31\INCLUDE\string.h 52: size_t      __cdecl  strspn(const char  *__s1, const char  *__s2);
\BC31\INCLUDE\string.h 53: char  * __cdecl  strstr(const char  *__s1, const char  *__s2);
\BC31\INCLUDE\string.h 54: char  * __cdecl  strtok(char  *__s1, const char  *__s2);
\BC31\INCLUDE\string.h 55: size_t      __cdecl strxfrm(char  *__s1, const char  *__s2,
\BC31\INCLUDE\string.h 56: size_t __n );
\BC31\INCLUDE\string.h 57: char  * __cdecl  _strerror(const char  *__s);
\BC31\INCLUDE\string.h 58: 
\BC31\INCLUDE\string.h 59: 
\BC31\INCLUDE\string.h 60: 
\BC31\INCLUDE\string.h 61: 
\BC31\INCLUDE\string.h 62: 
\BC31\INCLUDE\string.h 63: 
\BC31\INCLUDE\string.h 64: 
\BC31\INCLUDE\string.h 65: void  * __cdecl  memccpy(void  *__dest, const void  *__src,
\BC31\INCLUDE\string.h 66: int __c, size_t __n);
\BC31\INCLUDE\string.h 67: int         __cdecl  memicmp(const void  *__s1, const void  *__s2,
\BC31\INCLUDE\string.h 68: size_t __n);
\BC31\INCLUDE\string.h 69: void        __cdecl  movedata(unsigned __srcseg,unsigned __srcoff,
\BC31\INCLUDE\string.h 70: unsigned __dstseg,unsigned __dstoff, size_t __n);
\BC31\INCLUDE\string.h 71: char  * __cdecl stpcpy(char  *__dest, const char  *__src);
\BC31\INCLUDE\string.h 72: char  * __cdecl _stpcpy(char  *__dest, const char  *__src);
\BC31\INCLUDE\string.h 73: char  * __cdecl  strdup(const char  *__s);
\BC31\INCLUDE\string.h 74: int         __cdecl  stricmp(const char  *__s1, const char  *__s2);
\BC31\INCLUDE\string.h 75: char  * __cdecl  strlwr(char  *__s);
\BC31\INCLUDE\string.h 76: int         __cdecl  strnicmp(const char  *__s1, const char  *__s2,
\BC31\INCLUDE\string.h 77: size_t __maxlen);
\BC31\INCLUDE\string.h 78: char  * __cdecl  strnset(char  *__s, int __ch, size_t __n);
\BC31\INCLUDE\string.h 79: char  * __cdecl  strrev(char  *__s);
\BC31\INCLUDE\string.h 80: char  * __cdecl  strset(char  *__s, int __ch);
\BC31\INCLUDE\string.h 81: char  * __cdecl  strupr(char  *__s);
\BC31\INCLUDE\string.h 82: 
\BC31\INCLUDE\string.h 83: void    __far * __far __cdecl _fmemccpy(void __far *__dest, const void __far *__src,
\BC31\INCLUDE\string.h 84: int c, size_t __n);
\BC31\INCLUDE\string.h 85: void    __far * __far __cdecl _fmemchr(const void __far *__s, int c, size_t __n);
\BC31\INCLUDE\string.h 86: int           __far __cdecl _fmemcmp(const void __far *__s1, const void __far *__s2,
\BC31\INCLUDE\string.h 87: size_t __n);
\BC31\INCLUDE\string.h 88: void    __far * __far __cdecl _fmemcpy(void __far *__dest, const void __far *__src,
\BC31\INCLUDE\string.h 89: size_t __n);
\BC31\INCLUDE\string.h 90: int           __far __cdecl _fmemicmp(const void __far *__s1, const void __far *__s2,
\BC31\INCLUDE\string.h 91: size_t __n);
\BC31\INCLUDE\string.h 92: void    __far * __far __cdecl _fmemmove(void __far *__dest, const void __far *__src,
\BC31\INCLUDE\string.h 93: size_t __n);
\BC31\INCLUDE\string.h 94: void    __far * __far __cdecl _fmemset(void __far *__s, int c, size_t __n);
\BC31\INCLUDE\string.h 95: void          __far __cdecl _fmovmem(const void __far *__src, void __far *__dest,
\BC31\INCLUDE\string.h 96: unsigned __length);
\BC31\INCLUDE\string.h 97: void          __far __cdecl _fsetmem(void __far *__dest,unsigned __length,
\BC31\INCLUDE\string.h 98: char __value);
\BC31\INCLUDE\string.h 99: 
\BC31\INCLUDE\string.h 100: char    __far * __far __cdecl _fstrcat(char __far *__dest, const char __far *__src);
\BC31\INCLUDE\string.h 101: char    __far * __far __cdecl _fstrchr(const char __far *__s, int c);
\BC31\INCLUDE\string.h 102: int           __far __cdecl _fstrcmp(const char __far *__s1, const char __far *__s2);
\BC31\INCLUDE\string.h 103: char    __far * __far __cdecl _fstrcpy(char __far *__dest, const char __far *__src);
\BC31\INCLUDE\string.h 104: size_t        __far __cdecl _fstrcspn(const char __far *__s1, const char __far *__s2);
\BC31\INCLUDE\string.h 105: char    __far * __far __cdecl _fstrdup(const char __far *__s);
\BC31\INCLUDE\string.h 106: int           __far __cdecl _fstricmp(const char __far *__s1, const char __far *__s2);
\BC31\INCLUDE\string.h 107: size_t        __far __cdecl _fstrlen(const char __far *__s);
\BC31\INCLUDE\string.h 108: char    __far * __far __cdecl _fstrlwr(char __far *__s);
\BC31\INCLUDE\string.h 109: char    __far * __far __cdecl _fstrncat(char __far *__dest, const char __far *__src,
\BC31\INCLUDE\string.h 110: size_t maxlen);
\BC31\INCLUDE\string.h 111: int           __far __cdecl _fstrncmp(const char __far *__s1, const char __far *__s2,
\BC31\INCLUDE\string.h 112: size_t maxlen);
\BC31\INCLUDE\string.h 113: char    __far * __far __cdecl _fstrncpy(char __far *__dest, const char __far *__src,
\BC31\INCLUDE\string.h 114: size_t maxlen);
\BC31\INCLUDE\string.h 115: int           __far __cdecl _fstrnicmp(const char __far *__s1, const char __far *__s2,
\BC31\INCLUDE\string.h 116: size_t maxlen);
\BC31\INCLUDE\string.h 117: char    __far * __far __cdecl _fstrnset(char __far *__s, int ch, size_t __n);
\BC31\INCLUDE\string.h 118: char    __far * __far __cdecl _fstrpbrk(const char __far *__s1, const char __far *__s2);
\BC31\INCLUDE\string.h 119: char    __far * __far __cdecl _fstrrchr(const char __far *__s, int c);
\BC31\INCLUDE\string.h 120: char    __far * __far __cdecl _fstrrev(char __far *__s);
\BC31\INCLUDE\string.h 121: char    __far * __far __cdecl _fstrset(char __far *__s, int ch);
\BC31\INCLUDE\string.h 122: size_t        __far __cdecl _fstrspn(const char __far *__s1, const char __far *__s2);
\BC31\INCLUDE\string.h 123: char    __far * __far __cdecl _fstrstr(const char __far *__s1, const char __far *__s2);
\BC31\INCLUDE\string.h 124: char    __far * __far __cdecl _fstrtok(char __far *__s1, const char __far *__s2);
\BC31\INCLUDE\string.h 125: char    __far * __far __cdecl _fstrupr(char __far *__s);
\BC31\INCLUDE\string.h 126: 
\BC31\INCLUDE\string.h 127: 
\BC31\INCLUDE\string.h 128: 
\BC31\INCLUDE\string.h 129: 
\BC31\INCLUDE\string.h 130: 
\BC31\INCLUDE\string.h 131: 
\BC31\INCLUDE\string.h 132: 
\BC31\INCLUDE\string.h 133: 
\BC31\INCLUDE\string.h 134: 
\BC31\INCLUDE\string.h 135: 
\BC31\INCLUDE\string.h 136: 
\BC31\INCLUDE\string.h 137: 
\BC31\INCLUDE\string.h 138: 
\BC31\INCLUDE\string.h 139: 
\BC31\INCLUDE\string.h 140: void  * __cdecl  __memchr__  (const void  *__s, int __c, size_t __n);
\BC31\INCLUDE\string.h 141: int         __cdecl  __memcmp__(const void  *__s1,
\BC31\INCLUDE\string.h 142: const void  *__s2, size_t __n);
\BC31\INCLUDE\string.h 143: void  * __cdecl  __memcpy__(void  *__dest, const void  *__src,
\BC31\INCLUDE\string.h 144: size_t __n);
\BC31\INCLUDE\string.h 145: void  * __cdecl  __memset__(void  *__s, int __c, size_t __n);
\BC31\INCLUDE\string.h 146: 
\BC31\INCLUDE\string.h 147: char  * __cdecl __stpcpy__(char  *__dest, const char  *__src);
\BC31\INCLUDE\string.h 148: char  * __cdecl  __strcat__(char  *__dest, const char  *__src);
\BC31\INCLUDE\string.h 149: char  * __cdecl  __strchr__(const char  *__s, int __c);
\BC31\INCLUDE\string.h 150: int         __cdecl  __strcmp__(const char  *__s1, const char  *__s2);
\BC31\INCLUDE\string.h 151: char  * __cdecl  __strcpy__(char  *__dest, const char  *__src);
\BC31\INCLUDE\string.h 152: size_t      __cdecl  __strlen__(const char  *__s);
\BC31\INCLUDE\string.h 153: char  * __cdecl  __strncat__(char  *__dest, const char  *__src,
\BC31\INCLUDE\string.h 154: size_t __maxlen);
\BC31\INCLUDE\string.h 155: int         __cdecl  __strncmp__(const char  *__s1, const char  *__s2,
\BC31\INCLUDE\string.h 156: size_t __maxlen);
\BC31\INCLUDE\string.h 157: char  * __cdecl  __strncpy__(char  *__dest, const char  *__src,
\BC31\INCLUDE\string.h 158: size_t __maxlen);
\BC31\INCLUDE\string.h 159: char  * __cdecl  __strnset__(char  *__s, int __ch, size_t __n);
\BC31\INCLUDE\string.h 160: char  * __cdecl  __strrchr__(const char  *__s, int __c);
\BC31\INCLUDE\string.h 161: char  * __cdecl  __strset__(char  *__s, int __ch);
\BC31\INCLUDE\string.h 162: 
\BC31\INCLUDE\string.h 163: 
\BC31\INCLUDE\string.h 164: }
\BC31\INCLUDE\string.h 165: 
\BC31\INCLUDE\string.h 166: 
\BC31\INCLUDE\string.h 167: 
\BC31\INCLUDE\string.h 168: 
\BC31\INCLUDE\string.h 169: 
extsel.cpp 7: 
\BC31\INCLUDE\ctype.h 1: 
\BC31\INCLUDE\ctype.h 2: 
\BC31\INCLUDE\ctype.h 3: 
\BC31\INCLUDE\ctype.h 4: 
\BC31\INCLUDE\ctype.h 5: 
\BC31\INCLUDE\ctype.h 6: 
\BC31\INCLUDE\ctype.h 7: 
\BC31\INCLUDE\ctype.h 8: 
\BC31\INCLUDE\ctype.h 9: 
\BC31\INCLUDE\ctype.h 10: 
\BC31\INCLUDE\ctype.h 11: 
\BC31\INCLUDE\ctype.h 12: 
\BC31\INCLUDE\ctype.h 13: 
\BC31\INCLUDE\ctype.h 14: 
\BC31\INCLUDE\ctype.h 15: 
\BC31\INCLUDE\ctype.h 16: 
\BC31\INCLUDE\ctype.h 17: 
\BC31\INCLUDE\ctype.h 18: 
\BC31\INCLUDE\ctype.h 19: 
\BC31\INCLUDE\ctype.h 20: 
\BC31\INCLUDE\ctype.h 21: 
\BC31\INCLUDE\ctype.h 22: 
\BC31\INCLUDE\ctype.h 23: 
\BC31\INCLUDE\ctype.h 24: extern  char __cdecl _ctype[];    
\BC31\INCLUDE\ctype.h 25: 
\BC31\INCLUDE\ctype.h 26: 
\BC31\INCLUDE\ctype.h 27: extern "C" {
\BC31\INCLUDE\ctype.h 28: 
\BC31\INCLUDE\ctype.h 29: int __cdecl isalnum (int __c);
\BC31\INCLUDE\ctype.h 30: int __cdecl isalpha (int __c);
\BC31\INCLUDE\ctype.h 31: int __cdecl isascii (int __c);
\BC31\INCLUDE\ctype.h 32: int __cdecl iscntrl (int __c);
\BC31\INCLUDE\ctype.h 33: int __cdecl isdigit (int __c);
\BC31\INCLUDE\ctype.h 34: int __cdecl isgraph (int __c);
\BC31\INCLUDE\ctype.h 35: int __cdecl islower (int __c);
\BC31\INCLUDE\ctype.h 36: int __cdecl isprint (int __c);
\BC31\INCLUDE\ctype.h 37: int __cdecl ispunct (int __c);
\BC31\INCLUDE\ctype.h 38: int __cdecl isspace (int __c);
\BC31\INCLUDE\ctype.h 39: int __cdecl isupper (int __c);
\BC31\INCLUDE\ctype.h 40: int __cdecl isxdigit(int __c);
\BC31\INCLUDE\ctype.h 41: 
\BC31\INCLUDE\ctype.h 42: }
\BC31\INCLUDE\ctype.h 43: 
\BC31\INCLUDE\ctype.h 44: 
\BC31\INCLUDE\ctype.h 45: 
\BC31\INCLUDE\ctype.h 46: 
\BC31\INCLUDE\ctype.h 47: 
\BC31\INCLUDE\ctype.h 48: 
\BC31\INCLUDE\ctype.h 49: 
\BC31\INCLUDE\ctype.h 50: 
\BC31\INCLUDE\ctype.h 51: 
\BC31\INCLUDE\ctype.h 52: 
\BC31\INCLUDE\ctype.h 53: 
\BC31\INCLUDE\ctype.h 54: 
\BC31\INCLUDE\ctype.h 55: 
\BC31\INCLUDE\ctype.h 56: 
\BC31\INCLUDE\ctype.h 57: 
\BC31\INCLUDE\ctype.h 58: 
\BC31\INCLUDE\ctype.h 59: 
\BC31\INCLUDE\ctype.h 60: 
\BC31\INCLUDE\ctype.h 61: 
\BC31\INCLUDE\ctype.h 62: 
\BC31\INCLUDE\ctype.h 63: 
\BC31\INCLUDE\ctype.h 64: 
\BC31\INCLUDE\ctype.h 65: 
\BC31\INCLUDE\ctype.h 66: extern "C" {
\BC31\INCLUDE\ctype.h 67: 
\BC31\INCLUDE\ctype.h 68: int __cdecl tolower(int __ch);
\BC31\INCLUDE\ctype.h 69: int __cdecl _ftolower(int __ch);
\BC31\INCLUDE\ctype.h 70: int __cdecl toupper(int __ch);
\BC31\INCLUDE\ctype.h 71: int __cdecl _ftoupper(int __ch);
\BC31\INCLUDE\ctype.h 72: 
\BC31\INCLUDE\ctype.h 73: }
\BC31\INCLUDE\ctype.h 74: 
\BC31\INCLUDE\ctype.h 75: 
\BC31\INCLUDE\ctype.h 76: 
\BC31\INCLUDE\ctype.h 77: 
\BC31\INCLUDE\ctype.h 78: 
extsel.cpp 8: 
extsel.cpp 9: 
extsel.cpp 10: 
\CPP\LIB\TSWIN\tswin.hpp 1: 
\CPP\LIB\TSLIB\tslib.hpp 1: 
\CPP\LIB\TSLIB\tslib.hpp 2: 
\CPP\LIB\TSLIB\tslib.hpp 3: 
\CPP\LIB\TSLIB\tslib.hpp 4: 
\CPP\LIB\TSLIB\tslib.hpp 5: 
\CPP\LIB\TSLIB\tslib.hpp 6: 
\CPP\LIB\TSLIB\tslib.hpp 7: 
\CPP\LIB\TSLIB\tslib.hpp 8: 
\CPP\LIB\TSLIB\tslib.hpp 9: 
\CPP\LIB\TSLIB\tslib.hpp 10: 
\CPP\LIB\TSLIB\tslib.hpp 11: 
\CPP\LIB\TSLIB\tslib.hpp 12: 
\CPP\LIB\TSLIB\tslib.hpp 13: 
\CPP\LIB\TSLIB\tslib.hpp 14: 
\CPP\LIB\TSLIB\tslib.hpp 15: 
\CPP\LIB\TSLIB\tslib.hpp 16: 
\CPP\LIB\TSLIB\tslib.hpp 17:  
\CPP\LIB\TSLIB\tslib.hpp 18: 
\CPP\LIB\TSLIB\tslib.hpp 19: 
\CPP\LIB\TSLIB\tslib.hpp 20: 
\CPP\LIB\TSLIB\tslib.hpp 21: 
\CPP\LIB\TSLIB\tslib.hpp 22: 
\CPP\LIB\TSLIB\tslib.hpp 23: 
\CPP\LIB\TSLIB\tslib.hpp 24: 
\CPP\LIB\TSLIB\tslib.hpp 25: 
\CPP\LIB\TSLIB\tslib.hpp 26: 
\CPP\LIB\TSLIB\tslib.hpp 27: typedef unsigned char  byte;
\CPP\LIB\TSLIB\tslib.hpp 28: typedef unsigned short word;
\CPP\LIB\TSLIB\tslib.hpp 29: typedef          short sword;
\CPP\LIB\TSLIB\tslib.hpp 30: typedef unsigned long  dword;
\CPP\LIB\TSLIB\tslib.hpp 31: typedef          long  sdword;
\CPP\LIB\TSLIB\tslib.hpp 32: typedef unsigned char  bool;
\CPP\LIB\TSLIB\tslib.hpp 33: 
\CPP\LIB\TSLIB\tslib.hpp 34: 
\CPP\LIB\TSLIB\tslib.hpp 35: 
\CPP\LIB\TSLIB\tslib.hpp 36: 
\CPP\LIB\TSLIB\tslib.hpp 37: 
\CPP\LIB\TSLIB\tslib.hpp 38: 
\CPP\LIB\TSLIB\tslib.hpp 39: 
\CPP\LIB\TSLIB\tslib.hpp 40: 
\CPP\LIB\TSLIB\tslib.hpp 41: 
\CPP\LIB\TSLIB\tslib.hpp 42: 
\CPP\LIB\TSLIB\tslib.hpp 43: 
\CPP\LIB\TSLIB\tslib.hpp 44: 
\CPP\LIB\TSLIB\tslib.hpp 45: 
\CPP\LIB\TSLIB\tslib.hpp 46: 
\CPP\LIB\TSLIB\tslib.hpp 47: 
\CPP\LIB\TSLIB\tslib.hpp 48: 
\CPP\LIB\TSLIB\tslib.hpp 49: 
\CPP\LIB\TSLIB\tslib.hpp 50: 
\CPP\LIB\TSLIB\tslib.hpp 51: 
\CPP\LIB\TSLIB\tslib.hpp 52: 
\CPP\LIB\TSLIB\tslib.hpp 53: 
\CPP\LIB\TSLIB\tslib.hpp 54: 
\CPP\LIB\TSLIB\tslib.hpp 55: 
\CPP\LIB\TSLIB\tslib.hpp 56: 
\CPP\LIB\TSLIB\tslib.hpp 57: 
\CPP\LIB\TSLIB\tslib.hpp 58: 
\CPP\LIB\TSLIB\tslib.hpp 59: 
\CPP\LIB\TSLIB\tslib.hpp 60: 
\CPP\LIB\TSLIB\tslib.hpp 61: 
\CPP\LIB\TSLIB\tslib.hpp 62: 
\CPP\LIB\TSLIB\tslib.hpp 63: 
\CPP\LIB\TSLIB\tslib.hpp 64: 
\CPP\LIB\TSLIB\tslib.hpp 65: 
\CPP\LIB\TSLIB\tslib.hpp 66: 
\CPP\LIB\TSLIB\tslib.hpp 67: 
\CPP\LIB\TSLIB\tslib.hpp 68: 
\CPP\LIB\TSLIB\tslib.hpp 69: 
\CPP\LIB\TSLIB\tslib.hpp 70: 
\CPP\LIB\TSLIB\tslib.hpp 71: 
\CPP\LIB\TSLIB\tslib.hpp 72: 
\CPP\LIB\TSLIB\tslib.hpp 73: 
\CPP\LIB\TSLIB\tslib.hpp 74: 
\CPP\LIB\TSLIB\tslib.hpp 75: 
\CPP\LIB\TSLIB\tslib.hpp 76: 
\CPP\LIB\TSLIB\tslib.hpp 77: 
\CPP\LIB\TSLIB\tslib.hpp 78: 
\CPP\LIB\TSLIB\tslib.hpp 79: 
\CPP\LIB\TSLIB\tslib.hpp 80: 
\CPP\LIB\TSLIB\tslib.hpp 81: 
\CPP\LIB\TSLIB\tslib.hpp 82: 
\CPP\LIB\TSLIB\tslib.hpp 83: 
\CPP\LIB\TSLIB\tslib.hpp 84: 
\CPP\LIB\TSLIB\tslib.hpp 85: 
\CPP\LIB\TSLIB\tslib.hpp 86: class String;
\CPP\LIB\TSLIB\tslib.hpp 87: 
\CPP\LIB\TSLIB\tslib.hpp 88: const bool TRUE  = 1;
\CPP\LIB\TSLIB\tslib.hpp 89: const bool FALSE = 0;
\CPP\LIB\TSLIB\tslib.hpp 90: 
\CPP\LIB\TSLIB\tslib.hpp 91: 
\CPP\LIB\TSLIB\tslib.hpp 92: 
\CPP\LIB\TSLIB\tslib.hpp 93: 
\CPP\LIB\TSLIB\tslib.hpp 94: 
\CPP\LIB\TSLIB\tslib.hpp 95: 
\CPP\LIB\TSLIB\tslib.hpp 96: 
\CPP\LIB\TSLIB\tslib.hpp 97: 
\CPP\LIB\TSLIB\tslib.hpp 98: 
\CPP\LIB\TSLIB\tslib.hpp 99: 
\CPP\LIB\TSLIB\tslib.hpp 100: 
\CPP\LIB\TSLIB\tslib.hpp 101: 
\CPP\LIB\TSLIB\tslib.hpp 102: 
\CPP\LIB\TSLIB\tslib.hpp 103: 
\CPP\LIB\TSLIB\tslib.hpp 104: 
\CPP\LIB\TSLIB\tslib.hpp 105: 
\CPP\LIB\TSLIB\tslib.hpp 106: 
\CPP\LIB\TSLIB\tslib.hpp 107: 
\CPP\LIB\TSLIB\tslib.hpp 108: 
\CPP\LIB\TSLIB\tslib.hpp 109: 
\CPP\LIB\TSLIB\tslib.hpp 110: 
\CPP\LIB\TSLIB\tslib.hpp 111: inline bool
\CPP\LIB\TSLIB\tslib.hpp 112: TESTBIT(word val,int bit)
\CPP\LIB\TSLIB\tslib.hpp 113: {
\CPP\LIB\TSLIB\tslib.hpp 114: return (bool)!!(val & (1<<bit));
\CPP\LIB\TSLIB\tslib.hpp 115: }
\CPP\LIB\TSLIB\tslib.hpp 116: 
\CPP\LIB\TSLIB\tslib.hpp 117: inline bool
\CPP\LIB\TSLIB\tslib.hpp 118: TESTBIT(int val,int bit)
\CPP\LIB\TSLIB\tslib.hpp 119: {
\CPP\LIB\TSLIB\tslib.hpp 120: return (bool)!!(val & (1<<bit));
\CPP\LIB\TSLIB\tslib.hpp 121: }
\CPP\LIB\TSLIB\tslib.hpp 122: 
\CPP\LIB\TSLIB\tslib.hpp 123: inline bool
\CPP\LIB\TSLIB\tslib.hpp 124: TESTBIT(dword val,int bit)
\CPP\LIB\TSLIB\tslib.hpp 125: {
\CPP\LIB\TSLIB\tslib.hpp 126: return (bool)!!(val & (1L<<bit));
\CPP\LIB\TSLIB\tslib.hpp 127: }
\CPP\LIB\TSLIB\tslib.hpp 128: 
\CPP\LIB\TSLIB\tslib.hpp 129: inline bool
\CPP\LIB\TSLIB\tslib.hpp 130: TESTBIT(long val,int bit)
\CPP\LIB\TSLIB\tslib.hpp 131: {
\CPP\LIB\TSLIB\tslib.hpp 132: return (bool)!!(val & (1L<<bit));
\CPP\LIB\TSLIB\tslib.hpp 133: }
\CPP\LIB\TSLIB\tslib.hpp 134: 
\CPP\LIB\TSLIB\tslib.hpp 135: inline void
\CPP\LIB\TSLIB\tslib.hpp 136: SETBIT(word& val,int bit)
\CPP\LIB\TSLIB\tslib.hpp 137: {
\CPP\LIB\TSLIB\tslib.hpp 138: val |= word(1<<bit);
\CPP\LIB\TSLIB\tslib.hpp 139: }
\CPP\LIB\TSLIB\tslib.hpp 140: 
\CPP\LIB\TSLIB\tslib.hpp 141: inline void
\CPP\LIB\TSLIB\tslib.hpp 142: SETBIT(int& val,int bit)
\CPP\LIB\TSLIB\tslib.hpp 143: {
\CPP\LIB\TSLIB\tslib.hpp 144: val |= int(1<<bit);
\CPP\LIB\TSLIB\tslib.hpp 145: }
\CPP\LIB\TSLIB\tslib.hpp 146: 
\CPP\LIB\TSLIB\tslib.hpp 147: inline void
\CPP\LIB\TSLIB\tslib.hpp 148: SETBIT(dword& val,int bit)
\CPP\LIB\TSLIB\tslib.hpp 149: {
\CPP\LIB\TSLIB\tslib.hpp 150: val |= dword(1L<<bit);
\CPP\LIB\TSLIB\tslib.hpp 151: }
\CPP\LIB\TSLIB\tslib.hpp 152: 
\CPP\LIB\TSLIB\tslib.hpp 153: inline void
\CPP\LIB\TSLIB\tslib.hpp 154: SETBIT(long& val,int bit)
\CPP\LIB\TSLIB\tslib.hpp 155: {
\CPP\LIB\TSLIB\tslib.hpp 156: val |= long(1L<<bit);
\CPP\LIB\TSLIB\tslib.hpp 157: }
\CPP\LIB\TSLIB\tslib.hpp 158: 
\CPP\LIB\TSLIB\tslib.hpp 159: inline void
\CPP\LIB\TSLIB\tslib.hpp 160: CLEARBIT(word& val,int bit)
\CPP\LIB\TSLIB\tslib.hpp 161: {
\CPP\LIB\TSLIB\tslib.hpp 162: val &= word(~(1<<bit));
\CPP\LIB\TSLIB\tslib.hpp 163: }
\CPP\LIB\TSLIB\tslib.hpp 164: 
\CPP\LIB\TSLIB\tslib.hpp 165: inline void
\CPP\LIB\TSLIB\tslib.hpp 166: CLEARBIT(int& val,int bit)
\CPP\LIB\TSLIB\tslib.hpp 167: {
\CPP\LIB\TSLIB\tslib.hpp 168: val &= ~(1<<bit);
\CPP\LIB\TSLIB\tslib.hpp 169: }
\CPP\LIB\TSLIB\tslib.hpp 170: 
\CPP\LIB\TSLIB\tslib.hpp 171: inline void
\CPP\LIB\TSLIB\tslib.hpp 172: CLEARBIT(dword& val,int bit)
\CPP\LIB\TSLIB\tslib.hpp 173: {
\CPP\LIB\TSLIB\tslib.hpp 174: val &= ~(1L<<bit);
\CPP\LIB\TSLIB\tslib.hpp 175: }
\CPP\LIB\TSLIB\tslib.hpp 176: 
\CPP\LIB\TSLIB\tslib.hpp 177: inline void
\CPP\LIB\TSLIB\tslib.hpp 178: CLEARBIT(long& val,int bit)
\CPP\LIB\TSLIB\tslib.hpp 179: {
\CPP\LIB\TSLIB\tslib.hpp 180: val &= ~(1L<<bit);
\CPP\LIB\TSLIB\tslib.hpp 181: }
\CPP\LIB\TSLIB\tslib.hpp 182: 
\CPP\LIB\TSLIB\tslib.hpp 183: 
\CPP\LIB\TSLIB\tslib.hpp 184: 
\CPP\LIB\TSLIB\tslib.hpp 185: 
\CPP\LIB\TSLIB\tslib.hpp 186: 
\CPP\LIB\TSLIB\tslib.hpp 187: 
\CPP\LIB\TSLIB\tslib.hpp 188: 
\CPP\LIB\TSLIB\tslib.hpp 189: 
\CPP\LIB\TSLIB\tslib.hpp 190: 
\CPP\LIB\TSLIB\tslib.hpp 191: 
\CPP\LIB\TSLIB\tslib.hpp 192: 
\CPP\LIB\TSLIB\tslib.hpp 193: 
\CPP\LIB\TSLIB\tslib.hpp 194: 
\CPP\LIB\TSLIB\tslib.hpp 195: 
\CPP\LIB\TSLIB\tslib.hpp 196: 
\CPP\LIB\TSLIB\tslib.hpp 197: word crc(const char *);
\CPP\LIB\TSLIB\tslib.hpp 198: word crc(const void *,unsigned);
\CPP\LIB\TSLIB\tslib.hpp 199: word upcrc(const char *);
\CPP\LIB\TSLIB\tslib.hpp 200: 
\CPP\LIB\TSLIB\tslib.hpp 201: 
\CPP\LIB\TSLIB\tslib.hpp 202: 
\CPP\LIB\TSLIB\tslib.hpp 203: dword crc32   (const char *);
\CPP\LIB\TSLIB\tslib.hpp 204: dword upcrc32 (const char *);
\CPP\LIB\TSLIB\tslib.hpp 205: dword crc32   (const void *,unsigned);
\CPP\LIB\TSLIB\tslib.hpp 206: 
\CPP\LIB\TSLIB\tslib.hpp 207: void  sound(word freq);
\CPP\LIB\TSLIB\tslib.hpp 208: void  stopsound();
\CPP\LIB\TSLIB\tslib.hpp 209: void  soundclick();
\CPP\LIB\TSLIB\tslib.hpp 210: 
\CPP\LIB\TSLIB\tslib.hpp 211: extern "C"
\CPP\LIB\TSLIB\tslib.hpp 212: {
\CPP\LIB\TSLIB\tslib.hpp 213: 
\CPP\LIB\TSLIB\tslib.hpp 214: 
\CPP\LIB\TSLIB\tslib.hpp 215: const seek_set           = 0;
\CPP\LIB\TSLIB\tslib.hpp 216: const seek_cur           = 1;
\CPP\LIB\TSLIB\tslib.hpp 217: const seek_end           = 2;
\CPP\LIB\TSLIB\tslib.hpp 218: }
\CPP\LIB\TSLIB\tslib.hpp 219: 
\CPP\LIB\TSLIB\tslib.hpp 220: 
\CPP\LIB\TSLIB\tslib.hpp 221: bool get_ini_var(const char *fname,const char *varname,char *var,int max );
\CPP\LIB\TSLIB\tslib.hpp 222: bool set_ini_var(const char *fname,const char *varname,const char *var);
\CPP\LIB\TSLIB\tslib.hpp 223: 
\CPP\LIB\TSLIB\tslib.hpp 224: 
\CPP\LIB\TSLIB\tslib.hpp 225: bool   ts_MakeFullDir(char *dir);                      
\CPP\LIB\TSLIB\tslib.hpp 226: bool   ts_DirExists(char *dir);                        
\CPP\LIB\TSLIB\tslib.hpp 227: long   ts_CopyFile(char *from,char *to,int bufsize);   
\CPP\LIB\TSLIB\tslib.hpp 228: String ts_ResolveDir(char *dir);                       
\CPP\LIB\TSLIB\tslib.hpp 229: bool   ts_IsFullPath(char *s);                         
\CPP\LIB\TSLIB\tslib.hpp 230: void   ts_MakeInputPath(String& s);                    
\CPP\LIB\TSLIB\tslib.hpp 231: void   ts_MakeInputPath(char *s);                      
\CPP\LIB\TSLIB\tslib.hpp 232: bool   ts_SyncFileDate(char *fnSource,char *fn);       
\CPP\LIB\TSLIB\tslib.hpp 233: 
\CPP\LIB\TSLIB\tslib.hpp 234: 
\CPP\LIB\TSLIB\tslib.hpp 235: 
\CPP\LIB\TSLIB\tslib.hpp 236: 
\CPP\LIB\TSLIB\tslib.hpp 237: 
\CPP\LIB\TSLIB\tslib.hpp 238: 
\CPP\LIB\TSLIB\tslib.hpp 239: int NormalizeYear( int iYearVal );
\CPP\LIB\TSLIB\tslib.hpp 240: 
\CPP\LIB\TSLIB\tslib.hpp 241: 
\CPP\LIB\TSLIB\tslib.hpp 242: 
\CPP\LIB\TSLIB\tslib.hpp 243: 
\CPP\LIB\TSLIB\tslib.hpp 244: 
\CPP\LIB\TSLIB\tslib.hpp 245: void append_backspace(char *);
\CPP\LIB\TSLIB\tslib.hpp 246: void strip_linefeed(char *);
\CPP\LIB\TSLIB\tslib.hpp 247: void strip_trailing(char *);
\CPP\LIB\TSLIB\tslib.hpp 248: void strip_leading(char *);
\CPP\LIB\TSLIB\tslib.hpp 249: void strip_all(char *);
\CPP\LIB\TSLIB\tslib.hpp 250: 
\CPP\LIB\TSLIB\tslib.hpp 251: void c2pas(char *);
\CPP\LIB\TSLIB\tslib.hpp 252: void pas2c(char *);
\CPP\LIB\TSLIB\tslib.hpp 253: 
\CPP\LIB\TSLIB\tslib.hpp 254: 
\CPP\LIB\TSLIB\tslib.hpp 255: 
\CPP\LIB\TSLIB\tslib.hpp 256: 
\CPP\LIB\TSLIB\tslib.hpp 257: void sleep_clock();
\CPP\LIB\TSLIB\tslib.hpp 258: 
\CPP\LIB\TSLIB\tslib.hpp 259: 
\CPP\LIB\TSLIB\tslib.hpp 260: 
\CPP\LIB\TSLIB\tslib.hpp 261: 
\CPP\LIB\TSLIB\tslib.hpp 262: 
\CPP\LIB\TSLIB\tslib.hpp 263: 
\CPP\LIB\TSLIB\tslib.hpp 264: 
\CPP\LIB\TSLIB\tslib.hpp 265: 
\CPP\LIB\TSLIB\tslib.hpp 266: 
\CPP\LIB\TSLIB\tslib.hpp 267: 
\CPP\LIB\TSLIB\tslib.hpp 268: 
\CPP\LIB\TSLIB\tslib.hpp 269: 
\CPP\LIB\TSLIB\tslib.hpp 270: 
\CPP\LIB\TSLIB\tslib.hpp 271: 
\CPP\LIB\TSLIB\tslib.hpp 272: 
\CPP\LIB\TSLIB\tslib.hpp 273: 
\CPP\LIB\TSLIB\tslib.hpp 274: 
\CPP\LIB\TSLIB\tslib.hpp 275: 
\CPP\LIB\TSLIB\tslib.hpp 276: 
\CPP\LIB\TSLIB\tslib.hpp 277: 
\CPP\LIB\TSLIB\tslib.hpp 278: 
\CPP\LIB\TSLIB\tslib.hpp 279: 
\CPP\LIB\TSLIB\tslib.hpp 280: 
\CPP\LIB\TSLIB\tslib.hpp 281: 
\CPP\LIB\TSLIB\tslib.hpp 282: 
\CPP\LIB\TSLIB\tslib.hpp 283: inline dword
\CPP\LIB\TSLIB\tslib.hpp 284: clockticks()
\CPP\LIB\TSLIB\tslib.hpp 285: {
\CPP\LIB\TSLIB\tslib.hpp 286: return *((dword __far *)0x46C);
\CPP\LIB\TSLIB\tslib.hpp 287: }
\CPP\LIB\TSLIB\tslib.hpp 288: 
\CPP\LIB\TSLIB\tslib.hpp 289: inline dword
\CPP\LIB\TSLIB\tslib.hpp 290: clockdiff(dword prev)
\CPP\LIB\TSLIB\tslib.hpp 291: {
\CPP\LIB\TSLIB\tslib.hpp 292: return clockticks() - prev;
\CPP\LIB\TSLIB\tslib.hpp 293: }
\CPP\LIB\TSLIB\tslib.hpp 294: 
\CPP\LIB\TSLIB\tslib.hpp 295: 
\CPP\LIB\TSLIB\tslib.hpp 296: class String
\CPP\LIB\TSLIB\tslib.hpp 297: {
\CPP\LIB\TSLIB\tslib.hpp 298: public:
\CPP\LIB\TSLIB\tslib.hpp 299: enum justification { left , right , centered };
\CPP\LIB\TSLIB\tslib.hpp 300: 
\CPP\LIB\TSLIB\tslib.hpp 301: private:
\CPP\LIB\TSLIB\tslib.hpp 302: void adjustSize();
\CPP\LIB\TSLIB\tslib.hpp 303: void adjustSize(int l);
\CPP\LIB\TSLIB\tslib.hpp 304: 
\CPP\LIB\TSLIB\tslib.hpp 305: int size;
\CPP\LIB\TSLIB\tslib.hpp 306: 
\CPP\LIB\TSLIB\tslib.hpp 307: protected:
\CPP\LIB\TSLIB\tslib.hpp 308: char *s;
\CPP\LIB\TSLIB\tslib.hpp 309: 
\CPP\LIB\TSLIB\tslib.hpp 310: public:
\CPP\LIB\TSLIB\tslib.hpp 311: String();
\CPP\LIB\TSLIB\tslib.hpp 312: String(const String&);
\CPP\LIB\TSLIB\tslib.hpp 313: String(const char *);
\CPP\LIB\TSLIB\tslib.hpp 314: String(const char,int len=1);
\CPP\LIB\TSLIB\tslib.hpp 315: ~String();
\CPP\LIB\TSLIB\tslib.hpp 316: void  clear();
\CPP\LIB\TSLIB\tslib.hpp 317: char& operator[](int i)
\CPP\LIB\TSLIB\tslib.hpp 318: {
\CPP\LIB\TSLIB\tslib.hpp 319: return s[i];
\CPP\LIB\TSLIB\tslib.hpp 320: }
\CPP\LIB\TSLIB\tslib.hpp 321: operator char*() const
\CPP\LIB\TSLIB\tslib.hpp 322: {
\CPP\LIB\TSLIB\tslib.hpp 323: return s;
\CPP\LIB\TSLIB\tslib.hpp 324: }
\CPP\LIB\TSLIB\tslib.hpp 325: 
\CPP\LIB\TSLIB\tslib.hpp 326: void operator=(const char*);
\CPP\LIB\TSLIB\tslib.hpp 327: void operator=(const String&);
\CPP\LIB\TSLIB\tslib.hpp 328: void operator=(char);
\CPP\LIB\TSLIB\tslib.hpp 329: void operator=(int);
\CPP\LIB\TSLIB\tslib.hpp 330: void operator=(long);
\CPP\LIB\TSLIB\tslib.hpp 331: void operator+=(const String&);
\CPP\LIB\TSLIB\tslib.hpp 332: void operator+=(const char *);
\CPP\LIB\TSLIB\tslib.hpp 333: void operator+=(char);
\CPP\LIB\TSLIB\tslib.hpp 334: 
\CPP\LIB\TSLIB\tslib.hpp 335: int operator==(const char *str) const;
\CPP\LIB\TSLIB\tslib.hpp 336: int operator==(const String& str) const;
\CPP\LIB\TSLIB\tslib.hpp 337: int operator!=(const char *str) const;
\CPP\LIB\TSLIB\tslib.hpp 338: int operator!=(const String& str) const;
\CPP\LIB\TSLIB\tslib.hpp 339: 
\CPP\LIB\TSLIB\tslib.hpp 340: String& operator<<(const String&);
\CPP\LIB\TSLIB\tslib.hpp 341: String& operator<<(const char *);
\CPP\LIB\TSLIB\tslib.hpp 342: String& operator<<(char);
\CPP\LIB\TSLIB\tslib.hpp 343: String& operator<<(int);
\CPP\LIB\TSLIB\tslib.hpp 344: String& operator<<(long);
\CPP\LIB\TSLIB\tslib.hpp 345: 
\CPP\LIB\TSLIB\tslib.hpp 346: int replace(const char *s,const char *r,bool = FALSE,int max_count = 0);
\CPP\LIB\TSLIB\tslib.hpp 347: int find(const char *s,bool = FALSE) const;   
\CPP\LIB\TSLIB\tslib.hpp 348: 
\CPP\LIB\TSLIB\tslib.hpp 349: int fuzzySearch(const char *pattern , int degree = 75); 
\CPP\LIB\TSLIB\tslib.hpp 350: 
\CPP\LIB\TSLIB\tslib.hpp 351: String sub(int pos,int l) const;
\CPP\LIB\TSLIB\tslib.hpp 352: 
\CPP\LIB\TSLIB\tslib.hpp 353: void del(int pos,int len);              
\CPP\LIB\TSLIB\tslib.hpp 354: void insert(int pos,const char *str);   
\CPP\LIB\TSLIB\tslib.hpp 355: 
\CPP\LIB\TSLIB\tslib.hpp 356: char lastChar() const;
\CPP\LIB\TSLIB\tslib.hpp 357: char firstChar() const { return *s; }
\CPP\LIB\TSLIB\tslib.hpp 358: 
\CPP\LIB\TSLIB\tslib.hpp 359: void delFirst(char = '\0');
\CPP\LIB\TSLIB\tslib.hpp 360: void delLast(char = '\0');
\CPP\LIB\TSLIB\tslib.hpp 361: 
\CPP\LIB\TSLIB\tslib.hpp 362: int len() const;
\CPP\LIB\TSLIB\tslib.hpp 363: word crc() const;
\CPP\LIB\TSLIB\tslib.hpp 364: word upcrc() const;
\CPP\LIB\TSLIB\tslib.hpp 365: 
\CPP\LIB\TSLIB\tslib.hpp 366: void upperCase();
\CPP\LIB\TSLIB\tslib.hpp 367: void lowerCase();
\CPP\LIB\TSLIB\tslib.hpp 368: void mixedCase();
\CPP\LIB\TSLIB\tslib.hpp 369: 
\CPP\LIB\TSLIB\tslib.hpp 370: void ltrim();
\CPP\LIB\TSLIB\tslib.hpp 371: void rtrim();
\CPP\LIB\TSLIB\tslib.hpp 372: void  trim();
\CPP\LIB\TSLIB\tslib.hpp 373: 
\CPP\LIB\TSLIB\tslib.hpp 374: friend String operator+(const String&,const String&);
\CPP\LIB\TSLIB\tslib.hpp 375: friend String operator+(const String&,const char * );
\CPP\LIB\TSLIB\tslib.hpp 376: friend String operator+(const char * ,const String&);
\CPP\LIB\TSLIB\tslib.hpp 377: 
\CPP\LIB\TSLIB\tslib.hpp 378: void justify(justification , int len = 0);
\CPP\LIB\TSLIB\tslib.hpp 379: };
\CPP\LIB\TSLIB\tslib.hpp 380: 
\CPP\LIB\TSLIB\tslib.hpp 381: 
\CPP\LIB\TSLIB\tslib.hpp 382: 
\CPP\LIB\TSLIB\tslib.hpp 383: 
\CPP\LIB\TSLIB\tslib.hpp 384: 
\CPP\LIB\TSLIB\tslib.hpp 385: 
\CPP\LIB\TSLIB\tslib.hpp 386: 
\CPP\LIB\TSLIB\tslib.hpp 387: 
\CPP\LIB\TSLIB\tslib.hpp 388: 
\CPP\LIB\TSLIB\tslib.hpp 389: 
\CPP\LIB\TSLIB\tslib.hpp 390: 
\CPP\LIB\TSLIB\tslib.hpp 391: 
\CPP\LIB\TSLIB\tslib.hpp 392: 
\CPP\LIB\TSLIB\tslib.hpp 393: 
\CPP\LIB\TSLIB\tslib.hpp 394: 
\CPP\LIB\TSLIB\tslib.hpp 395: 
\CPP\LIB\TSLIB\tslib.hpp 396: 
\CPP\LIB\TSLIB\tslib.hpp 397: 
\CPP\LIB\TSLIB\tslib.hpp 398: class Date
\CPP\LIB\TSLIB\tslib.hpp 399: {
\CPP\LIB\TSLIB\tslib.hpp 400: char _d ,
\CPP\LIB\TSLIB\tslib.hpp 401: _m ,
\CPP\LIB\TSLIB\tslib.hpp 402: _y ;
\CPP\LIB\TSLIB\tslib.hpp 403: 
\CPP\LIB\TSLIB\tslib.hpp 404: int compare(const Date&) const;
\CPP\LIB\TSLIB\tslib.hpp 405: void  parse_key(String&) const;
\CPP\LIB\TSLIB\tslib.hpp 406: 
\CPP\LIB\TSLIB\tslib.hpp 407: static char *weekdays[7];
\CPP\LIB\TSLIB\tslib.hpp 408: static char *s_weekdays[7];
\CPP\LIB\TSLIB\tslib.hpp 409: static char *l_weekdays[7];
\CPP\LIB\TSLIB\tslib.hpp 410: static char *months[12];
\CPP\LIB\TSLIB\tslib.hpp 411: static char *l_months[12];
\CPP\LIB\TSLIB\tslib.hpp 412: 
\CPP\LIB\TSLIB\tslib.hpp 413: public:
\CPP\LIB\TSLIB\tslib.hpp 414: Date();                   
\CPP\LIB\TSLIB\tslib.hpp 415: Date(long);               
\CPP\LIB\TSLIB\tslib.hpp 416: Date(int,int,int);        
\CPP\LIB\TSLIB\tslib.hpp 417: Date(const Date&);
\CPP\LIB\TSLIB\tslib.hpp 418: 
\CPP\LIB\TSLIB\tslib.hpp 419: void operator=( const Date& );
\CPP\LIB\TSLIB\tslib.hpp 420: 
\CPP\LIB\TSLIB\tslib.hpp 421: void operator()(int day,int month,int year) 
\CPP\LIB\TSLIB\tslib.hpp 422: {
\CPP\LIB\TSLIB\tslib.hpp 423: set(day,month,year);
\CPP\LIB\TSLIB\tslib.hpp 424: }
\CPP\LIB\TSLIB\tslib.hpp 425: 
\CPP\LIB\TSLIB\tslib.hpp 426: char& operator[](int i);  
\CPP\LIB\TSLIB\tslib.hpp 427: 
\CPP\LIB\TSLIB\tslib.hpp 428: int day() const           
\CPP\LIB\TSLIB\tslib.hpp 429: {
\CPP\LIB\TSLIB\tslib.hpp 430: return _d;
\CPP\LIB\TSLIB\tslib.hpp 431: }
\CPP\LIB\TSLIB\tslib.hpp 432: int month() const         
\CPP\LIB\TSLIB\tslib.hpp 433: {
\CPP\LIB\TSLIB\tslib.hpp 434: return _m;
\CPP\LIB\TSLIB\tslib.hpp 435: }
\CPP\LIB\TSLIB\tslib.hpp 436: int year() const          
\CPP\LIB\TSLIB\tslib.hpp 437: {
\CPP\LIB\TSLIB\tslib.hpp 438: return _y;
\CPP\LIB\TSLIB\tslib.hpp 439: }
\CPP\LIB\TSLIB\tslib.hpp 440: 
\CPP\LIB\TSLIB\tslib.hpp 441: bool ok() const;           
\CPP\LIB\TSLIB\tslib.hpp 442: 
\CPP\LIB\TSLIB\tslib.hpp 443: int dayNum() const;       
\CPP\LIB\TSLIB\tslib.hpp 444: int weekDay() const;      
\CPP\LIB\TSLIB\tslib.hpp 445: int weekNum() const;      
\CPP\LIB\TSLIB\tslib.hpp 446: int daysInMonth(int = 0) const; 
\CPP\LIB\TSLIB\tslib.hpp 447: int daysInYear(int = 0) const;  
\CPP\LIB\TSLIB\tslib.hpp 448: int weeksInYear(int = 0) const; 
\CPP\LIB\TSLIB\tslib.hpp 449: 
\CPP\LIB\TSLIB\tslib.hpp 450: int age(const Date& birthdate);
\CPP\LIB\TSLIB\tslib.hpp 451: 
\CPP\LIB\TSLIB\tslib.hpp 452: operator long() const;    
\CPP\LIB\TSLIB\tslib.hpp 453: Date& operator=(long);    
\CPP\LIB\TSLIB\tslib.hpp 454: 
\CPP\LIB\TSLIB\tslib.hpp 455: void operator++()
\CPP\LIB\TSLIB\tslib.hpp 456: {
\CPP\LIB\TSLIB\tslib.hpp 457: (*this) = long(*this) + 1;
\CPP\LIB\TSLIB\tslib.hpp 458: }
\CPP\LIB\TSLIB\tslib.hpp 459: void operator++(int)
\CPP\LIB\TSLIB\tslib.hpp 460: {
\CPP\LIB\TSLIB\tslib.hpp 461: operator++();
\CPP\LIB\TSLIB\tslib.hpp 462: }
\CPP\LIB\TSLIB\tslib.hpp 463: void operator--()
\CPP\LIB\TSLIB\tslib.hpp 464: {
\CPP\LIB\TSLIB\tslib.hpp 465: (*this) = long(*this) - 1;
\CPP\LIB\TSLIB\tslib.hpp 466: }
\CPP\LIB\TSLIB\tslib.hpp 467: void operator--(int)
\CPP\LIB\TSLIB\tslib.hpp 468: {
\CPP\LIB\TSLIB\tslib.hpp 469: operator--();
\CPP\LIB\TSLIB\tslib.hpp 470: }
\CPP\LIB\TSLIB\tslib.hpp 471: void operator+=(int n)
\CPP\LIB\TSLIB\tslib.hpp 472: {
\CPP\LIB\TSLIB\tslib.hpp 473: (*this) = long(*this) + n;
\CPP\LIB\TSLIB\tslib.hpp 474: }
\CPP\LIB\TSLIB\tslib.hpp 475: void operator-=(int n)
\CPP\LIB\TSLIB\tslib.hpp 476: {
\CPP\LIB\TSLIB\tslib.hpp 477: (*this) = long(*this) - n;
\CPP\LIB\TSLIB\tslib.hpp 478: }
\CPP\LIB\TSLIB\tslib.hpp 479: 
\CPP\LIB\TSLIB\tslib.hpp 480: void set(int,int,int);    
\CPP\LIB\TSLIB\tslib.hpp 481: void today();             
\CPP\LIB\TSLIB\tslib.hpp 482: 
\CPP\LIB\TSLIB\tslib.hpp 483: int operator<(const Date&) const;     
\CPP\LIB\TSLIB\tslib.hpp 484: int operator>(const Date&) const;     
\CPP\LIB\TSLIB\tslib.hpp 485: int operator==(const Date&) const;    
\CPP\LIB\TSLIB\tslib.hpp 486: int operator!=(const Date&) const;    
\CPP\LIB\TSLIB\tslib.hpp 487: int operator<=(const Date&) const;    
\CPP\LIB\TSLIB\tslib.hpp 488: int operator>=(const Date&) const;    
\CPP\LIB\TSLIB\tslib.hpp 489: 
\CPP\LIB\TSLIB\tslib.hpp 490: int operator-(const Date&) const;     
\CPP\LIB\TSLIB\tslib.hpp 491: 
\CPP\LIB\TSLIB\tslib.hpp 492: bool leap()               const;
\CPP\LIB\TSLIB\tslib.hpp 493: 
\CPP\LIB\TSLIB\tslib.hpp 494: String format(const char *fmt) const;
\CPP\LIB\TSLIB\tslib.hpp 495: 
\CPP\LIB\TSLIB\tslib.hpp 496: void fileDate(word);  
\CPP\LIB\TSLIB\tslib.hpp 497: };
\CPP\LIB\TSLIB\tslib.hpp 498: 
\CPP\LIB\TSLIB\tslib.hpp 499: 
\CPP\LIB\TSLIB\tslib.hpp 500: 
\CPP\LIB\TSLIB\tslib.hpp 501: 
\CPP\LIB\TSLIB\tslib.hpp 502: class Time
\CPP\LIB\TSLIB\tslib.hpp 503: {
\CPP\LIB\TSLIB\tslib.hpp 504: char _h ,
\CPP\LIB\TSLIB\tslib.hpp 505: _m ,
\CPP\LIB\TSLIB\tslib.hpp 506: _s ;
\CPP\LIB\TSLIB\tslib.hpp 507: 
\CPP\LIB\TSLIB\tslib.hpp 508: void Time::parse_key(String& key) const;
\CPP\LIB\TSLIB\tslib.hpp 509: public:
\CPP\LIB\TSLIB\tslib.hpp 510: 
\CPP\LIB\TSLIB\tslib.hpp 511: Time();
\CPP\LIB\TSLIB\tslib.hpp 512: Time(int)
\CPP\LIB\TSLIB\tslib.hpp 513: {
\CPP\LIB\TSLIB\tslib.hpp 514: now();
\CPP\LIB\TSLIB\tslib.hpp 515: }
\CPP\LIB\TSLIB\tslib.hpp 516: Time(int h,int m,int s)
\CPP\LIB\TSLIB\tslib.hpp 517: {
\CPP\LIB\TSLIB\tslib.hpp 518: set(h,m,s);
\CPP\LIB\TSLIB\tslib.hpp 519: }
\CPP\LIB\TSLIB\tslib.hpp 520: 
\CPP\LIB\TSLIB\tslib.hpp 521: Time(const Time&);
\CPP\LIB\TSLIB\tslib.hpp 522: 
\CPP\LIB\TSLIB\tslib.hpp 523: void operator=(const Time&);
\CPP\LIB\TSLIB\tslib.hpp 524: 
\CPP\LIB\TSLIB\tslib.hpp 525: void operator()(int h,int m,int s)
\CPP\LIB\TSLIB\tslib.hpp 526: {
\CPP\LIB\TSLIB\tslib.hpp 527: set(h,m,s);
\CPP\LIB\TSLIB\tslib.hpp 528: }
\CPP\LIB\TSLIB\tslib.hpp 529: 
\CPP\LIB\TSLIB\tslib.hpp 530: char& operator[](int i);
\CPP\LIB\TSLIB\tslib.hpp 531: 
\CPP\LIB\TSLIB\tslib.hpp 532: int hour() const
\CPP\LIB\TSLIB\tslib.hpp 533: {
\CPP\LIB\TSLIB\tslib.hpp 534: return _h;
\CPP\LIB\TSLIB\tslib.hpp 535: }
\CPP\LIB\TSLIB\tslib.hpp 536: int minute() const
\CPP\LIB\TSLIB\tslib.hpp 537: {
\CPP\LIB\TSLIB\tslib.hpp 538: return _m;
\CPP\LIB\TSLIB\tslib.hpp 539: }
\CPP\LIB\TSLIB\tslib.hpp 540: int seconds() const
\CPP\LIB\TSLIB\tslib.hpp 541: {
\CPP\LIB\TSLIB\tslib.hpp 542: return _s;
\CPP\LIB\TSLIB\tslib.hpp 543: }
\CPP\LIB\TSLIB\tslib.hpp 544: 
\CPP\LIB\TSLIB\tslib.hpp 545: operator long() const;
\CPP\LIB\TSLIB\tslib.hpp 546: 
\CPP\LIB\TSLIB\tslib.hpp 547: long operator-(const Time& t) const;
\CPP\LIB\TSLIB\tslib.hpp 548: 
\CPP\LIB\TSLIB\tslib.hpp 549: void operator-=(const Time&);
\CPP\LIB\TSLIB\tslib.hpp 550: void operator+=(const Time&);
\CPP\LIB\TSLIB\tslib.hpp 551: void operator=(long);
\CPP\LIB\TSLIB\tslib.hpp 552: 
\CPP\LIB\TSLIB\tslib.hpp 553: void set(int h,int m,int s);     
\CPP\LIB\TSLIB\tslib.hpp 554: void now();                      
\CPP\LIB\TSLIB\tslib.hpp 555: 
\CPP\LIB\TSLIB\tslib.hpp 556: String format(const char *) const;
\CPP\LIB\TSLIB\tslib.hpp 557: 
\CPP\LIB\TSLIB\tslib.hpp 558: void fileTime(word);
\CPP\LIB\TSLIB\tslib.hpp 559: 
\CPP\LIB\TSLIB\tslib.hpp 560: int operator<(const Time&)  const;   
\CPP\LIB\TSLIB\tslib.hpp 561: int operator>(const Time&)  const;   
\CPP\LIB\TSLIB\tslib.hpp 562: int operator==(const Time&) const;   
\CPP\LIB\TSLIB\tslib.hpp 563: int operator!=(const Time&) const;   
\CPP\LIB\TSLIB\tslib.hpp 564: int operator<=(const Time&) const;   
\CPP\LIB\TSLIB\tslib.hpp 565: int operator>=(const Time&) const;   
\CPP\LIB\TSLIB\tslib.hpp 566: };
\CPP\LIB\TSLIB\tslib.hpp 567: 
\CPP\LIB\TSLIB\tslib.hpp 568: 
\CPP\LIB\TSLIB\tslib.hpp 569: 
\CPP\LIB\TSLIB\tslib.hpp 570: 
\CPP\LIB\TSLIB\tslib.hpp 571: class FileName : public String
\CPP\LIB\TSLIB\tslib.hpp 572: {
\CPP\LIB\TSLIB\tslib.hpp 573: public:
\CPP\LIB\TSLIB\tslib.hpp 574: FileName() : String() {}
\CPP\LIB\TSLIB\tslib.hpp 575: FileName(const char *p,const char *f=0,const char *e=0);
\CPP\LIB\TSLIB\tslib.hpp 576: void operator()(const char *p);
\CPP\LIB\TSLIB\tslib.hpp 577: void operator()(const char *p,const char *f);
\CPP\LIB\TSLIB\tslib.hpp 578: void operator()(const char *p,const char *f,const char *e);
\CPP\LIB\TSLIB\tslib.hpp 579: void appendBS();
\CPP\LIB\TSLIB\tslib.hpp 580: void stripPath();
\CPP\LIB\TSLIB\tslib.hpp 581: void stripExt();
\CPP\LIB\TSLIB\tslib.hpp 582: void stripName();
\CPP\LIB\TSLIB\tslib.hpp 583: void changeExt(const char *ext);
\CPP\LIB\TSLIB\tslib.hpp 584: void changePath(const char *path);
\CPP\LIB\TSLIB\tslib.hpp 585: void operator=(const char*);
\CPP\LIB\TSLIB\tslib.hpp 586: void operator=(const FileName&);
\CPP\LIB\TSLIB\tslib.hpp 587: void operator=(char);
\CPP\LIB\TSLIB\tslib.hpp 588: void operator=(int);
\CPP\LIB\TSLIB\tslib.hpp 589: void operator=(long);
\CPP\LIB\TSLIB\tslib.hpp 590: void fit(int size);
\CPP\LIB\TSLIB\tslib.hpp 591: };
\CPP\LIB\TSLIB\tslib.hpp 592: 
\CPP\LIB\TSLIB\tslib.hpp 593: const DIR_NORMAL = 0x00;
\CPP\LIB\TSLIB\tslib.hpp 594: const DIR_RDONLY = 0x01;
\CPP\LIB\TSLIB\tslib.hpp 595: const DIR_HIDDEN = 0x02;
\CPP\LIB\TSLIB\tslib.hpp 596: const DIR_SYSTEM = 0x04;
\CPP\LIB\TSLIB\tslib.hpp 597: const DIR_LABEL  = 0x08;
\CPP\LIB\TSLIB\tslib.hpp 598: const DIR_DIREC  = 0x10;
\CPP\LIB\TSLIB\tslib.hpp 599: const DIR_ARCH   = 0x20;
\CPP\LIB\TSLIB\tslib.hpp 600: 
\CPP\LIB\TSLIB\tslib.hpp 601: class DirScan
\CPP\LIB\TSLIB\tslib.hpp 602: {
\CPP\LIB\TSLIB\tslib.hpp 603: void *data;
\CPP\LIB\TSLIB\tslib.hpp 604: int ok;
\CPP\LIB\TSLIB\tslib.hpp 605: public:
\CPP\LIB\TSLIB\tslib.hpp 606: 
\CPP\LIB\TSLIB\tslib.hpp 607: DirScan();
\CPP\LIB\TSLIB\tslib.hpp 608: DirScan(const char *wildcard,int attr);
\CPP\LIB\TSLIB\tslib.hpp 609: DirScan(const char *wildcard);
\CPP\LIB\TSLIB\tslib.hpp 610: ~DirScan();
\CPP\LIB\TSLIB\tslib.hpp 611: 
\CPP\LIB\TSLIB\tslib.hpp 612: int first(const char *fname,int attr);           
\CPP\LIB\TSLIB\tslib.hpp 613: int first(const char *fname);                    
\CPP\LIB\TSLIB\tslib.hpp 614: int next();                                
\CPP\LIB\TSLIB\tslib.hpp 615: int operator++()    { return next(); }     
\CPP\LIB\TSLIB\tslib.hpp 616: int operator++(int) { return next(); }     
\CPP\LIB\TSLIB\tslib.hpp 617: 
\CPP\LIB\TSLIB\tslib.hpp 618: operator int() const
\CPP\LIB\TSLIB\tslib.hpp 619: {
\CPP\LIB\TSLIB\tslib.hpp 620: return ok;
\CPP\LIB\TSLIB\tslib.hpp 621: }
\CPP\LIB\TSLIB\tslib.hpp 622: 
\CPP\LIB\TSLIB\tslib.hpp 623: char *name() const;
\CPP\LIB\TSLIB\tslib.hpp 624: Date date()  const;
\CPP\LIB\TSLIB\tslib.hpp 625: Time time()  const;
\CPP\LIB\TSLIB\tslib.hpp 626: long size()  const;
\CPP\LIB\TSLIB\tslib.hpp 627: int flags()  const;
\CPP\LIB\TSLIB\tslib.hpp 628: 
\CPP\LIB\TSLIB\tslib.hpp 629: operator char*() const  { return name(); }
\CPP\LIB\TSLIB\tslib.hpp 630: operator Date()  const  { return date(); }
\CPP\LIB\TSLIB\tslib.hpp 631: operator Time()  const  { return time(); }
\CPP\LIB\TSLIB\tslib.hpp 632: };
\CPP\LIB\TSLIB\tslib.hpp 633: 
\CPP\LIB\TSLIB\tslib.hpp 634: 
\CPP\LIB\TSLIB\tslib.hpp 635: 
\CPP\LIB\TSLIB\tslib.hpp 636: 
\CPP\LIB\TSLIB\tslib.hpp 637: const word fmode_read     = 0x000;  
\CPP\LIB\TSLIB\tslib.hpp 638: const word fmode_write    = 0x001;  
\CPP\LIB\TSLIB\tslib.hpp 639: const word fmode_rw       = 0x002;  
\CPP\LIB\TSLIB\tslib.hpp 640: 
\CPP\LIB\TSLIB\tslib.hpp 641: const word fmode_create   = 0x004;  
\CPP\LIB\TSLIB\tslib.hpp 642: 
\CPP\LIB\TSLIB\tslib.hpp 643: const word fmode_excl     = 0x010;  
\CPP\LIB\TSLIB\tslib.hpp 644: const word fmode_denywr   = 0x020;  
\CPP\LIB\TSLIB\tslib.hpp 645: const word fmode_denyrd   = 0x030;  
\CPP\LIB\TSLIB\tslib.hpp 646: const word fmode_shared   = 0x040;  
\CPP\LIB\TSLIB\tslib.hpp 647: 
\CPP\LIB\TSLIB\tslib.hpp 648: const word fmode_text     = 0x100;  
\CPP\LIB\TSLIB\tslib.hpp 649: const word fmode_copen    = 0x200;  
\CPP\LIB\TSLIB\tslib.hpp 650: const word fmode_buffered = 0x400;  
\CPP\LIB\TSLIB\tslib.hpp 651: const word fmode_append   = 0x800;  
\CPP\LIB\TSLIB\tslib.hpp 652: 
\CPP\LIB\TSLIB\tslib.hpp 653: const word file_error_ok       = 0;    
\CPP\LIB\TSLIB\tslib.hpp 654: const word file_error_nofile   = 2;    
\CPP\LIB\TSLIB\tslib.hpp 655: const word file_error_nopath   = 3;    
\CPP\LIB\TSLIB\tslib.hpp 656: const word file_error_numfiles = 4;    
\CPP\LIB\TSLIB\tslib.hpp 657: const word file_error_noaccess = 5;    
\CPP\LIB\TSLIB\tslib.hpp 658: const word file_error_badfh    = 6;    
\CPP\LIB\TSLIB\tslib.hpp 659: 
\CPP\LIB\TSLIB\tslib.hpp 660: class File
\CPP\LIB\TSLIB\tslib.hpp 661: {
\CPP\LIB\TSLIB\tslib.hpp 662: 
\CPP\LIB\TSLIB\tslib.hpp 663: 
\CPP\LIB\TSLIB\tslib.hpp 664: 
\CPP\LIB\TSLIB\tslib.hpp 665: int   fh;             
\CPP\LIB\TSLIB\tslib.hpp 666: byte *buffer;         
\CPP\LIB\TSLIB\tslib.hpp 667: byte *bufPtr;         
\CPP\LIB\TSLIB\tslib.hpp 668: word  bufSize;        
\CPP\LIB\TSLIB\tslib.hpp 669: word  bytesInBuf;     
\CPP\LIB\TSLIB\tslib.hpp 670: long  bufPos;         
\CPP\LIB\TSLIB\tslib.hpp 671: word  mode;           
\CPP\LIB\TSLIB\tslib.hpp 672: byte  lastAction;     
\CPP\LIB\TSLIB\tslib.hpp 673: bool  atEof;          
\CPP\LIB\TSLIB\tslib.hpp 674: word  errorCode;      
\CPP\LIB\TSLIB\tslib.hpp 675: 
\CPP\LIB\TSLIB\tslib.hpp 676: void clearError()
\CPP\LIB\TSLIB\tslib.hpp 677: {
\CPP\LIB\TSLIB\tslib.hpp 678: atEof     = FALSE;
\CPP\LIB\TSLIB\tslib.hpp 679: errorCode = FALSE;
\CPP\LIB\TSLIB\tslib.hpp 680: }
\CPP\LIB\TSLIB\tslib.hpp 681: void init();
\CPP\LIB\TSLIB\tslib.hpp 682: bool buffered() const
\CPP\LIB\TSLIB\tslib.hpp 683: {
\CPP\LIB\TSLIB\tslib.hpp 684: return (bool)!!(mode & fmode_buffered);
\CPP\LIB\TSLIB\tslib.hpp 685: }
\CPP\LIB\TSLIB\tslib.hpp 686: bool textMode() const
\CPP\LIB\TSLIB\tslib.hpp 687: {
\CPP\LIB\TSLIB\tslib.hpp 688: return (bool)!!(mode & fmode_text);
\CPP\LIB\TSLIB\tslib.hpp 689: }
\CPP\LIB\TSLIB\tslib.hpp 690: bool fillBuffer();
\CPP\LIB\TSLIB\tslib.hpp 691: 
\CPP\LIB\TSLIB\tslib.hpp 692: public:
\CPP\LIB\TSLIB\tslib.hpp 693: File(const char *fname,word mode = fmode_read,word bufsize = 0);
\CPP\LIB\TSLIB\tslib.hpp 694: File()
\CPP\LIB\TSLIB\tslib.hpp 695: {
\CPP\LIB\TSLIB\tslib.hpp 696: init();
\CPP\LIB\TSLIB\tslib.hpp 697: }
\CPP\LIB\TSLIB\tslib.hpp 698: ~File()
\CPP\LIB\TSLIB\tslib.hpp 699: {
\CPP\LIB\TSLIB\tslib.hpp 700: close();
\CPP\LIB\TSLIB\tslib.hpp 701: }
\CPP\LIB\TSLIB\tslib.hpp 702: bool open(const char *fname,word mode = fmode_read,word bufsize = 0);
\CPP\LIB\TSLIB\tslib.hpp 703: void close();
\CPP\LIB\TSLIB\tslib.hpp 704: bool eof() const
\CPP\LIB\TSLIB\tslib.hpp 705: {
\CPP\LIB\TSLIB\tslib.hpp 706: return atEof;
\CPP\LIB\TSLIB\tslib.hpp 707: }
\CPP\LIB\TSLIB\tslib.hpp 708: word error() const
\CPP\LIB\TSLIB\tslib.hpp 709: {
\CPP\LIB\TSLIB\tslib.hpp 710: return errorCode;
\CPP\LIB\TSLIB\tslib.hpp 711: }
\CPP\LIB\TSLIB\tslib.hpp 712: void enableBuffer();
\CPP\LIB\TSLIB\tslib.hpp 713: void disableBuffer();
\CPP\LIB\TSLIB\tslib.hpp 714: word read(void *p,word size);
\CPP\LIB\TSLIB\tslib.hpp 715: word write(const void *p,word size);
\CPP\LIB\TSLIB\tslib.hpp 716: long seek(long pos,int mode = seek_set);
\CPP\LIB\TSLIB\tslib.hpp 717: int  readByte();
\CPP\LIB\TSLIB\tslib.hpp 718: bool writeByte(byte c);
\CPP\LIB\TSLIB\tslib.hpp 719: bool readLine(char *s,int max );
\CPP\LIB\TSLIB\tslib.hpp 720: String readLine();
\CPP\LIB\TSLIB\tslib.hpp 721: 
\CPP\LIB\TSLIB\tslib.hpp 722: File& operator<<(const char *);
\CPP\LIB\TSLIB\tslib.hpp 723: File& operator<<(int);
\CPP\LIB\TSLIB\tslib.hpp 724: File& operator<<(word);
\CPP\LIB\TSLIB\tslib.hpp 725: File& operator<<(long);
\CPP\LIB\TSLIB\tslib.hpp 726: File& operator<<(dword);
\CPP\LIB\TSLIB\tslib.hpp 727: File& operator<<(char);
\CPP\LIB\TSLIB\tslib.hpp 728: File& operator<<(const String& s) { return operator<<((char *)s); }
\CPP\LIB\TSLIB\tslib.hpp 729: 
\CPP\LIB\TSLIB\tslib.hpp 730: File& operator>>(char&);
\CPP\LIB\TSLIB\tslib.hpp 731: File& operator>>(int&);
\CPP\LIB\TSLIB\tslib.hpp 732: File& operator>>(word&);
\CPP\LIB\TSLIB\tslib.hpp 733: File& operator>>(long&);
\CPP\LIB\TSLIB\tslib.hpp 734: File& operator>>(dword&);
\CPP\LIB\TSLIB\tslib.hpp 735: File& operator>>(String& s) { s = readLine(); return *this; }
\CPP\LIB\TSLIB\tslib.hpp 736: 
\CPP\LIB\TSLIB\tslib.hpp 737: bool printf(const char *fmt,...);
\CPP\LIB\TSLIB\tslib.hpp 738: long pos();
\CPP\LIB\TSLIB\tslib.hpp 739: long len();
\CPP\LIB\TSLIB\tslib.hpp 740: void cut();
\CPP\LIB\TSLIB\tslib.hpp 741: void rewind()
\CPP\LIB\TSLIB\tslib.hpp 742: {
\CPP\LIB\TSLIB\tslib.hpp 743: seek(0);
\CPP\LIB\TSLIB\tslib.hpp 744: }
\CPP\LIB\TSLIB\tslib.hpp 745: bool opened() const
\CPP\LIB\TSLIB\tslib.hpp 746: {
\CPP\LIB\TSLIB\tslib.hpp 747: return bool(fh>0);
\CPP\LIB\TSLIB\tslib.hpp 748: }
\CPP\LIB\TSLIB\tslib.hpp 749: 
\CPP\LIB\TSLIB\tslib.hpp 750: bool lock(long pos,long len);
\CPP\LIB\TSLIB\tslib.hpp 751: bool unlock(long pos,long len);
\CPP\LIB\TSLIB\tslib.hpp 752: void flush();
\CPP\LIB\TSLIB\tslib.hpp 753: 
\CPP\LIB\TSLIB\tslib.hpp 754: 
\CPP\LIB\TSLIB\tslib.hpp 755: 
\CPP\LIB\TSLIB\tslib.hpp 756: int   dosHandle() { return fh;    }
\CPP\LIB\TSLIB\tslib.hpp 757: 
\CPP\LIB\TSLIB\tslib.hpp 758: };
\CPP\LIB\TSLIB\tslib.hpp 759: 
\CPP\LIB\TSLIB\tslib.hpp 760: 
\CPP\LIB\TSLIB\tslib.hpp 761: 
\CPP\LIB\TSLIB\tslib.hpp 762: 
\CPP\LIB\TSLIB\tslib.hpp 763: 
\CPP\LIB\TSLIB\tslib.hpp 764: 
\CPP\LIB\TSLIB\tslib.hpp 765: 
\CPP\LIB\TSLIB\tslib.hpp 766: 
\CPP\LIB\TSLIB\tslib.hpp 767: 
\CPP\LIB\TSLIB\tslib.hpp 768: 
\CPP\LIB\TSLIB\tslib.hpp 769: 
\CPP\LIB\TSLIB\tslib.hpp 770: 
\CPP\LIB\TSLIB\tslib.hpp 771: 
\CPP\LIB\TSLIB\tslib.hpp 772: class TextFile : public File
\CPP\LIB\TSLIB\tslib.hpp 773: {
\CPP\LIB\TSLIB\tslib.hpp 774: public:
\CPP\LIB\TSLIB\tslib.hpp 775: TextFile()
\CPP\LIB\TSLIB\tslib.hpp 776: {
\CPP\LIB\TSLIB\tslib.hpp 777: }
\CPP\LIB\TSLIB\tslib.hpp 778: TextFile(const char *fname , word mode = fmode_read , word bufsize=512)
\CPP\LIB\TSLIB\tslib.hpp 779: : File(fname , mode | fmode_text , bufsize)
\CPP\LIB\TSLIB\tslib.hpp 780: {
\CPP\LIB\TSLIB\tslib.hpp 781: }
\CPP\LIB\TSLIB\tslib.hpp 782: bool open(const char *fname , word mode = fmode_read , word bufsize=512)
\CPP\LIB\TSLIB\tslib.hpp 783: {
\CPP\LIB\TSLIB\tslib.hpp 784: return File::open(fname , mode | fmode_text , bufsize);
\CPP\LIB\TSLIB\tslib.hpp 785: }
\CPP\LIB\TSLIB\tslib.hpp 786: };
\CPP\LIB\TSLIB\tslib.hpp 787: 
\CPP\LIB\TSLIB\tslib.hpp 788: class BitArray
\CPP\LIB\TSLIB\tslib.hpp 789: {
\CPP\LIB\TSLIB\tslib.hpp 790: long start;
\CPP\LIB\TSLIB\tslib.hpp 791: word *array;
\CPP\LIB\TSLIB\tslib.hpp 792: public:
\CPP\LIB\TSLIB\tslib.hpp 793: BitArray(long size,long s = 0);
\CPP\LIB\TSLIB\tslib.hpp 794: ~BitArray();
\CPP\LIB\TSLIB\tslib.hpp 795: bool operator[](long i) const;
\CPP\LIB\TSLIB\tslib.hpp 796: void set(long i);
\CPP\LIB\TSLIB\tslib.hpp 797: void clear(long i);
\CPP\LIB\TSLIB\tslib.hpp 798: };
\CPP\LIB\TSLIB\tslib.hpp 799: 
\CPP\LIB\TSLIB\tslib.hpp 800: const byte LOGSTYLE_NORMAL = 0;
\CPP\LIB\TSLIB\tslib.hpp 801: 
\CPP\LIB\TSLIB\tslib.hpp 802: class LogFile
\CPP\LIB\TSLIB\tslib.hpp 803: {
\CPP\LIB\TSLIB\tslib.hpp 804: FileName name;
\CPP\LIB\TSLIB\tslib.hpp 805: byte     logStyle;
\CPP\LIB\TSLIB\tslib.hpp 806: public:
\CPP\LIB\TSLIB\tslib.hpp 807: LogFile();
\CPP\LIB\TSLIB\tslib.hpp 808: ~LogFile();
\CPP\LIB\TSLIB\tslib.hpp 809: 
\CPP\LIB\TSLIB\tslib.hpp 810: bool open(const char *fn , byte style = LOGSTYLE_NORMAL);
\CPP\LIB\TSLIB\tslib.hpp 811: bool write(const char *str,...);
\CPP\LIB\TSLIB\tslib.hpp 812: };
\CPP\LIB\TSLIB\tslib.hpp 813: 
\CPP\LIB\TSLIB\tslib.hpp 814: char *form(const char * ...);
\CPP\LIB\TSLIB\tslib.hpp 815: 
\CPP\LIB\TSLIB\tslib.hpp 816: 
\CPP\LIB\TSLIB\tslib.hpp 817: 
\CPP\LIB\TSLIB\tslib.hpp 818: 
\CPP\LIB\TSLIB\tslib.hpp 819: 
\CPP\LIB\TSLIB\tslib.hpp 820: 
\CPP\LIB\TSLIB\tslib.hpp 821: 
\CPP\LIB\TSLIB\tslib.hpp 822: 
\CPP\LIB\TSLIB\tslib.hpp 823: 
\CPP\LIB\TSLIB\tslib.hpp 824: 
\CPP\LIB\TSLIB\tslib.hpp 825: 
\CPP\LIB\TSLIB\tslib.hpp 826: 
\CPP\LIB\TSLIB\tslib.hpp 827: 
\CPP\LIB\TSLIB\tslib.hpp 828: 
\CPP\LIB\TSLIB\tslib.hpp 829: 
\CPP\LIB\TSLIB\tslib.hpp 830: 
\CPP\LIB\TSLIB\tslib.hpp 831: 
\CPP\LIB\TSLIB\tslib.hpp 832: 
\CPP\LIB\TSLIB\tslib.hpp 833: 
\CPP\LIB\TSLIB\tslib.hpp 834: 
\CPP\LIB\TSLIB\tslib.hpp 835: 
\CPP\LIB\TSLIB\tslib.hpp 836: 
\CPP\LIB\TSLIB\tslib.hpp 837: 
\CPP\LIB\TSLIB\tslib.hpp 838: 
\CPP\LIB\TSLIB\tslib.hpp 839: 
\CPP\LIB\TSLIB\tslib.hpp 840: 
\CPP\LIB\TSLIB\tslib.hpp 841: 
\CPP\LIB\TSLIB\tslib.hpp 842: 
\CPP\LIB\TSLIB\tslib.hpp 843: 
\CPP\LIB\TSLIB\tslib.hpp 844: 
\CPP\LIB\TSLIB\tslib.hpp 845: 
\CPP\LIB\TSLIB\tslib.hpp 846: 
\CPP\LIB\TSLIB\tslib.hpp 847: 
\CPP\LIB\TSLIB\tslib.hpp 848: 
\CPP\LIB\TSLIB\tslib.hpp 849: 
\CPP\LIB\TSLIB\tslib.hpp 850: 
\CPP\LIB\TSLIB\tslib.hpp 851: 
\CPP\LIB\TSWIN\tswin.hpp 2: 
\CPP\LIB\TSWIN\tswin.hpp 3: 
\CPP\LIB\TSWIN\tswin.hpp 4: 
\CPP\LIB\TSWIN\tswin.hpp 5: 
\CPP\LIB\TSWIN\tswin.hpp 6: 
\CPP\LIB\TSWIN\tswin.hpp 7: 
\CPP\LIB\TSWIN\tswin.hpp 8: 
\CPP\LIB\TSWIN\tswin.hpp 9: 
\CPP\LIB\TSWIN\tswin.hpp 10: 
\CPP\LIB\TSWIN\tswin.hpp 11: 
\CPP\LIB\TSWIN\tswin.hpp 12: 
\CPP\LIB\TSWIN\tswin.hpp 13: 
\CPP\LIB\TSWIN\tswin.hpp 14: 
\CPP\LIB\TSWIN\tswin.hpp 15: 
\CPP\LIB\TSWIN\tswin.hpp 16: 
\CPP\LIB\TSWIN\tswin.hpp 17: 
\CPP\LIB\TSWIN\tswin.hpp 18: 
\CPP\LIB\TSWIN\tswin.hpp 19: 
\CPP\LIB\TSWIN\tswin.hpp 20: 
\CPP\LIB\TSWIN\tswin.hpp 21: 
\CPP\LIB\TSWIN\tswin.hpp 22: 
\CPP\LIB\TSWIN\tswin.hpp 23: 
\CPP\LIB\TSWIN\tswin.hpp 24: 
\CPP\LIB\TSWIN\tswin.hpp 25: 
\CPP\LIB\TSWIN\tswin.hpp 26: 
\CPP\LIB\TSWIN\tswin.hpp 27: 
\CPP\LIB\TSWIN\tswin.hpp 28: 
\CPP\LIB\TSWIN\tswin.hpp 29: 
\CPP\LIB\TSWIN\tswin.hpp 30: 
\CPP\LIB\TSWIN\tswin.hpp 31: 
\CPP\LIB\TSWIN\tswin.hpp 32: 
\CPP\LIB\TSWIN\tswin.hpp 33: 
\CPP\LIB\TSWIN\tswin.hpp 34: 
\CPP\LIB\TSWIN\tswin.hpp 35: 
\CPP\LIB\TSWIN\tswin.hpp 36: 
\CPP\LIB\TSWIN\tswin.hpp 37: 
\CPP\LIB\TSWIN\tswin.hpp 38: 
\CPP\LIB\TSWIN\tswin.hpp 39: 
\CPP\LIB\TSWIN\tswin.hpp 40: 
\CPP\LIB\TSWIN\tswin.hpp 41: 
\CPP\LIB\TSWIN\tswin.hpp 42: 
\CPP\LIB\TSWIN\tswin.hpp 43: 
\CPP\LIB\TSWIN\tswin.hpp 44: 
\CPP\LIB\TSWIN\tswin.hpp 45: 
\CPP\LIB\TSWIN\tswin.hpp 46: 
\CPP\LIB\TSWIN\tswin.hpp 47: 
\CPP\LIB\TSWIN\tswin.hpp 48: typedef byte ATTR;
\CPP\LIB\TSWIN\tswin.hpp 49: 
\CPP\LIB\TSWIN\tswin.hpp 50: 
\CPP\LIB\TSWIN\tswin.hpp 51: typedef word KEY;
\CPP\LIB\TSWIN\tswin.hpp 52: 
\CPP\LIB\TSWIN\tswin.hpp 53: 
\CPP\LIB\TSWIN\tswin.hpp 54: const KEY KEY_NONE = 0x0000U;
\CPP\LIB\TSWIN\tswin.hpp 55: 
\CPP\LIB\TSWIN\tswin.hpp 56: const KEY KEY_F1   = 0x3B00U;
\CPP\LIB\TSWIN\tswin.hpp 57: const KEY KEY_F2   = 0x3C00U;
\CPP\LIB\TSWIN\tswin.hpp 58: const KEY KEY_F3   = 0x3D00U;
\CPP\LIB\TSWIN\tswin.hpp 59: const KEY KEY_F4   = 0x3E00U;
\CPP\LIB\TSWIN\tswin.hpp 60: const KEY KEY_F5   = 0x3F00U;
\CPP\LIB\TSWIN\tswin.hpp 61: const KEY KEY_F6   = 0x4000U;
\CPP\LIB\TSWIN\tswin.hpp 62: const KEY KEY_F7   = 0x4100U;
\CPP\LIB\TSWIN\tswin.hpp 63: const KEY KEY_F8   = 0x4200U;
\CPP\LIB\TSWIN\tswin.hpp 64: const KEY KEY_F9   = 0x4300U;
\CPP\LIB\TSWIN\tswin.hpp 65: const KEY KEY_F10  = 0x4400U;
\CPP\LIB\TSWIN\tswin.hpp 66: 
\CPP\LIB\TSWIN\tswin.hpp 67: const KEY KEY_SF1  = 0x5400U;
\CPP\LIB\TSWIN\tswin.hpp 68: const KEY KEY_SF2  = 0x5500U;
\CPP\LIB\TSWIN\tswin.hpp 69: const KEY KEY_SF3  = 0x5600U;
\CPP\LIB\TSWIN\tswin.hpp 70: const KEY KEY_SF4  = 0x5700U;
\CPP\LIB\TSWIN\tswin.hpp 71: const KEY KEY_SF5  = 0x5800U;
\CPP\LIB\TSWIN\tswin.hpp 72: const KEY KEY_SF6  = 0x5900U;
\CPP\LIB\TSWIN\tswin.hpp 73: const KEY KEY_SF7  = 0x5A00U;
\CPP\LIB\TSWIN\tswin.hpp 74: const KEY KEY_SF8  = 0x5B00U;
\CPP\LIB\TSWIN\tswin.hpp 75: const KEY KEY_SF9  = 0x5C00U;
\CPP\LIB\TSWIN\tswin.hpp 76: const KEY KEY_SF10 = 0x5D00U;
\CPP\LIB\TSWIN\tswin.hpp 77: 
\CPP\LIB\TSWIN\tswin.hpp 78: const KEY KEY_CF1  = 0x5E00U;
\CPP\LIB\TSWIN\tswin.hpp 79: const KEY KEY_CF2  = 0x5F00U;
\CPP\LIB\TSWIN\tswin.hpp 80: const KEY KEY_CF3  = 0x6000U;
\CPP\LIB\TSWIN\tswin.hpp 81: const KEY KEY_CF4  = 0x6100U;
\CPP\LIB\TSWIN\tswin.hpp 82: const KEY KEY_CF5  = 0x6200U;
\CPP\LIB\TSWIN\tswin.hpp 83: const KEY KEY_CF6  = 0x6300U;
\CPP\LIB\TSWIN\tswin.hpp 84: const KEY KEY_CF7  = 0x6400U;
\CPP\LIB\TSWIN\tswin.hpp 85: const KEY KEY_CF8  = 0x6500U;
\CPP\LIB\TSWIN\tswin.hpp 86: const KEY KEY_CF9  = 0x6600U;
\CPP\LIB\TSWIN\tswin.hpp 87: const KEY KEY_CF10 = 0x6700U;
\CPP\LIB\TSWIN\tswin.hpp 88: 
\CPP\LIB\TSWIN\tswin.hpp 89: const KEY KEY_AF1  = 0x6800U;
\CPP\LIB\TSWIN\tswin.hpp 90: const KEY KEY_AF2  = 0x6900U;
\CPP\LIB\TSWIN\tswin.hpp 91: const KEY KEY_AF3  = 0x6A00U;
\CPP\LIB\TSWIN\tswin.hpp 92: const KEY KEY_AF4  = 0x6B00U;
\CPP\LIB\TSWIN\tswin.hpp 93: const KEY KEY_AF5  = 0x6C00U;
\CPP\LIB\TSWIN\tswin.hpp 94: const KEY KEY_AF6  = 0x6D00U;
\CPP\LIB\TSWIN\tswin.hpp 95: const KEY KEY_AF7  = 0x6E00U;
\CPP\LIB\TSWIN\tswin.hpp 96: const KEY KEY_AF8  = 0x6F00U;
\CPP\LIB\TSWIN\tswin.hpp 97: const KEY KEY_AF9  = 0x7000U;
\CPP\LIB\TSWIN\tswin.hpp 98: const KEY KEY_AF10 = 0x7100U;
\CPP\LIB\TSWIN\tswin.hpp 99: 
\CPP\LIB\TSWIN\tswin.hpp 100: const KEY KEY_ALT1 = 0x7800U;
\CPP\LIB\TSWIN\tswin.hpp 101: const KEY KEY_ALT2 = 0x7900U;
\CPP\LIB\TSWIN\tswin.hpp 102: const KEY KEY_ALT3 = 0x7A00U;
\CPP\LIB\TSWIN\tswin.hpp 103: const KEY KEY_ALT4 = 0x7B00U;
\CPP\LIB\TSWIN\tswin.hpp 104: const KEY KEY_ALT5 = 0x7C00U;
\CPP\LIB\TSWIN\tswin.hpp 105: const KEY KEY_ALT6 = 0x7D00U;
\CPP\LIB\TSWIN\tswin.hpp 106: const KEY KEY_ALT7 = 0x7E00U;
\CPP\LIB\TSWIN\tswin.hpp 107: const KEY KEY_ALT8 = 0x7F00U;
\CPP\LIB\TSWIN\tswin.hpp 108: const KEY KEY_ALT9 = 0x8000U;
\CPP\LIB\TSWIN\tswin.hpp 109: const KEY KEY_ALT0 = 0x8100U;
\CPP\LIB\TSWIN\tswin.hpp 110: 
\CPP\LIB\TSWIN\tswin.hpp 111: const KEY KEY_ALTA = 0x1E00U;
\CPP\LIB\TSWIN\tswin.hpp 112: const KEY KEY_ALTB = 0x3000U;
\CPP\LIB\TSWIN\tswin.hpp 113: const KEY KEY_ALTC = 0x2E00U;
\CPP\LIB\TSWIN\tswin.hpp 114: const KEY KEY_ALTD = 0x2000U;
\CPP\LIB\TSWIN\tswin.hpp 115: const KEY KEY_ALTE = 0x1200U;
\CPP\LIB\TSWIN\tswin.hpp 116: const KEY KEY_ALTF = 0x2100U;
\CPP\LIB\TSWIN\tswin.hpp 117: const KEY KEY_ALTG = 0x2200U;
\CPP\LIB\TSWIN\tswin.hpp 118: const KEY KEY_ALTH = 0x2300U;
\CPP\LIB\TSWIN\tswin.hpp 119: const KEY KEY_ALTI = 0x1700U;
\CPP\LIB\TSWIN\tswin.hpp 120: const KEY KEY_ALTJ = 0x2400U;
\CPP\LIB\TSWIN\tswin.hpp 121: const KEY KEY_ALTK = 0x2500U;
\CPP\LIB\TSWIN\tswin.hpp 122: const KEY KEY_ALTL = 0x2600U;
\CPP\LIB\TSWIN\tswin.hpp 123: const KEY KEY_ALTM = 0x3200U;
\CPP\LIB\TSWIN\tswin.hpp 124: const KEY KEY_ALTN = 0x3100U;
\CPP\LIB\TSWIN\tswin.hpp 125: const KEY KEY_ALTO = 0x1800U;
\CPP\LIB\TSWIN\tswin.hpp 126: const KEY KEY_ALTP = 0x1900U;
\CPP\LIB\TSWIN\tswin.hpp 127: const KEY KEY_ALTQ = 0x1000U;
\CPP\LIB\TSWIN\tswin.hpp 128: const KEY KEY_ALTR = 0x1300U;
\CPP\LIB\TSWIN\tswin.hpp 129: const KEY KEY_ALTS = 0x1F00U;
\CPP\LIB\TSWIN\tswin.hpp 130: const KEY KEY_ALTT = 0x1400U;
\CPP\LIB\TSWIN\tswin.hpp 131: const KEY KEY_ALTU = 0x1600U;
\CPP\LIB\TSWIN\tswin.hpp 132: const KEY KEY_ALTV = 0x2F00U;
\CPP\LIB\TSWIN\tswin.hpp 133: const KEY KEY_ALTW = 0x1100U;
\CPP\LIB\TSWIN\tswin.hpp 134: const KEY KEY_ALTX = 0x2D00U;
\CPP\LIB\TSWIN\tswin.hpp 135: const KEY KEY_ALTY = 0x1500U;
\CPP\LIB\TSWIN\tswin.hpp 136: const KEY KEY_ALTZ = 0x2C00U;
\CPP\LIB\TSWIN\tswin.hpp 137: 
\CPP\LIB\TSWIN\tswin.hpp 138: const KEY KEY_CTLA = 0x0001U;
\CPP\LIB\TSWIN\tswin.hpp 139: const KEY KEY_CTLB = 0x0002U;
\CPP\LIB\TSWIN\tswin.hpp 140: const KEY KEY_CTLC = 0x0003U;
\CPP\LIB\TSWIN\tswin.hpp 141: const KEY KEY_CTLD = 0x0004U;
\CPP\LIB\TSWIN\tswin.hpp 142: const KEY KEY_CTLE = 0x0005U;
\CPP\LIB\TSWIN\tswin.hpp 143: const KEY KEY_CTLF = 0x0006U;
\CPP\LIB\TSWIN\tswin.hpp 144: const KEY KEY_CTLG = 0x0007U;
\CPP\LIB\TSWIN\tswin.hpp 145: const KEY KEY_CTLH = 0x0008U;
\CPP\LIB\TSWIN\tswin.hpp 146: const KEY KEY_CTLI = 0x0009U;
\CPP\LIB\TSWIN\tswin.hpp 147: const KEY KEY_CTLJ = 0x000AU;
\CPP\LIB\TSWIN\tswin.hpp 148: const KEY KEY_CTLK = 0x000BU;
\CPP\LIB\TSWIN\tswin.hpp 149: const KEY KEY_CTLL = 0x000CU;
\CPP\LIB\TSWIN\tswin.hpp 150: const KEY KEY_CTLM = 0x000DU;
\CPP\LIB\TSWIN\tswin.hpp 151: const KEY KEY_CTLN = 0x000EU;
\CPP\LIB\TSWIN\tswin.hpp 152: const KEY KEY_CTLO = 0x000FU;
\CPP\LIB\TSWIN\tswin.hpp 153: const KEY KEY_CTLP = 0x0010U;
\CPP\LIB\TSWIN\tswin.hpp 154: const KEY KEY_CTLQ = 0x0011U;
\CPP\LIB\TSWIN\tswin.hpp 155: const KEY KEY_CTLR = 0x0012U;
\CPP\LIB\TSWIN\tswin.hpp 156: const KEY KEY_CTLS = 0x0013U;
\CPP\LIB\TSWIN\tswin.hpp 157: const KEY KEY_CTLT = 0x0014U;
\CPP\LIB\TSWIN\tswin.hpp 158: const KEY KEY_CTLU = 0x0015U;
\CPP\LIB\TSWIN\tswin.hpp 159: const KEY KEY_CTLV = 0x0016U;
\CPP\LIB\TSWIN\tswin.hpp 160: const KEY KEY_CTLW = 0x0017U;
\CPP\LIB\TSWIN\tswin.hpp 161: const KEY KEY_CTLX = 0x0018U;
\CPP\LIB\TSWIN\tswin.hpp 162: const KEY KEY_CTLY = 0x0019U;
\CPP\LIB\TSWIN\tswin.hpp 163: const KEY KEY_CTLZ = 0x001AU;
\CPP\LIB\TSWIN\tswin.hpp 164: 
\CPP\LIB\TSWIN\tswin.hpp 165: const KEY KEY_DEL  = 0x5300U;
\CPP\LIB\TSWIN\tswin.hpp 166: const KEY KEY_INS  = 0x5200U;
\CPP\LIB\TSWIN\tswin.hpp 167: const KEY KEY_HOME = 0x4700U;
\CPP\LIB\TSWIN\tswin.hpp 168: const KEY KEY_END  = 0x4F00U;
\CPP\LIB\TSWIN\tswin.hpp 169: 
\CPP\LIB\TSWIN\tswin.hpp 170: const KEY KEY_PGUP = 0x4900U;
\CPP\LIB\TSWIN\tswin.hpp 171: const KEY KEY_PGDN = 0x5100U;
\CPP\LIB\TSWIN\tswin.hpp 172: const KEY KEY_UP   = 0x4800U;
\CPP\LIB\TSWIN\tswin.hpp 173: const KEY KEY_DN   = 0x5000U;
\CPP\LIB\TSWIN\tswin.hpp 174: const KEY KEY_LT   = 0x4B00U;
\CPP\LIB\TSWIN\tswin.hpp 175: const KEY KEY_RT   = 0x4D00U;
\CPP\LIB\TSWIN\tswin.hpp 176: 
\CPP\LIB\TSWIN\tswin.hpp 177: const KEY KEY_ESC  = 0x001BU;
\CPP\LIB\TSWIN\tswin.hpp 178: const KEY KEY_ENT  = 0x000DU;
\CPP\LIB\TSWIN\tswin.hpp 179: const KEY KEY_RET  = 0x000DU;
\CPP\LIB\TSWIN\tswin.hpp 180: const KEY KEY_TAB  = 0x0009U;
\CPP\LIB\TSWIN\tswin.hpp 181: const KEY KEY_STAB = 0x0F00U;
\CPP\LIB\TSWIN\tswin.hpp 182: 
\CPP\LIB\TSWIN\tswin.hpp 183: const KEY KEY_CPGUP = 0x8400U;
\CPP\LIB\TSWIN\tswin.hpp 184: const KEY KEY_CPGDN = 0x7600U;
\CPP\LIB\TSWIN\tswin.hpp 185: 
\CPP\LIB\TSWIN\tswin.hpp 186: const KEY KEY_CTL_LT = 0x7300U;
\CPP\LIB\TSWIN\tswin.hpp 187: const KEY KEY_CTL_RT = 0x7400U;
\CPP\LIB\TSWIN\tswin.hpp 188: 
\CPP\LIB\TSWIN\tswin.hpp 189: 
\CPP\LIB\TSWIN\tswin.hpp 190: 
\CPP\LIB\TSWIN\tswin.hpp 191: extern char __far *tsw_videobase; 
\CPP\LIB\TSWIN\tswin.hpp 192: extern byte      tsw_videocard; 
\CPP\LIB\TSWIN\tswin.hpp 193: extern byte      tsw_scrmode;   
\CPP\LIB\TSWIN\tswin.hpp 194: extern int       tsw_vsize;     
\CPP\LIB\TSWIN\tswin.hpp 195: extern int       tsw_hsize;     
\CPP\LIB\TSWIN\tswin.hpp 196: extern int       tsw_OS;        
\CPP\LIB\TSWIN\tswin.hpp 197: extern bool      tsw_shutup;    
\CPP\LIB\TSWIN\tswin.hpp 198: extern bool      tsw_cursorstate;
\CPP\LIB\TSWIN\tswin.hpp 199: 
\CPP\LIB\TSWIN\tswin.hpp 200: const int OS_DOS       = 1;
\CPP\LIB\TSWIN\tswin.hpp 201: const int OS_DESQVIEW  = 2;
\CPP\LIB\TSWIN\tswin.hpp 202: const int OS_DOUBLEDOS = 3;
\CPP\LIB\TSWIN\tswin.hpp 203: const int OS_TOPVIEW   = 4;
\CPP\LIB\TSWIN\tswin.hpp 204: const int OS_OS2       = 5;
\CPP\LIB\TSWIN\tswin.hpp 205: const int OS_WINDOWS   = 6;
\CPP\LIB\TSWIN\tswin.hpp 206: 
\CPP\LIB\TSWIN\tswin.hpp 207: 
\CPP\LIB\TSWIN\tswin.hpp 208: 
\CPP\LIB\TSWIN\tswin.hpp 209: 
\CPP\LIB\TSWIN\tswin.hpp 210: 
\CPP\LIB\TSWIN\tswin.hpp 211: 
\CPP\LIB\TSWIN\tswin.hpp 212: 
\CPP\LIB\TSWIN\tswin.hpp 213: 
\CPP\LIB\TSWIN\tswin.hpp 214: 
\CPP\LIB\TSWIN\tswin.hpp 215: 
\CPP\LIB\TSWIN\tswin.hpp 216: 
\CPP\LIB\TSWIN\tswin.hpp 217: 
\CPP\LIB\TSWIN\tswin.hpp 218: 
\CPP\LIB\TSWIN\tswin.hpp 219: 
\CPP\LIB\TSWIN\tswin.hpp 220: 
\CPP\LIB\TSWIN\tswin.hpp 221: 
\CPP\LIB\TSWIN\tswin.hpp 222: 
\CPP\LIB\TSWIN\tswin.hpp 223: 
\CPP\LIB\TSWIN\tswin.hpp 224: 
\CPP\LIB\TSWIN\tswin.hpp 225: 
\CPP\LIB\TSWIN\tswin.hpp 226: class Window;
\CPP\LIB\TSWIN\tswin.hpp 227: 
\CPP\LIB\TSWIN\tswin.hpp 228: struct Field
\CPP\LIB\TSWIN\tswin.hpp 229: {
\CPP\LIB\TSWIN\tswin.hpp 230: int type;
\CPP\LIB\TSWIN\tswin.hpp 231: void *value;
\CPP\LIB\TSWIN\tswin.hpp 232: void *data;
\CPP\LIB\TSWIN\tswin.hpp 233: KEY (*func)(int,Window&,int,int,char,void *);
\CPP\LIB\TSWIN\tswin.hpp 234: int flags;
\CPP\LIB\TSWIN\tswin.hpp 235: int len;
\CPP\LIB\TSWIN\tswin.hpp 236: int width;
\CPP\LIB\TSWIN\tswin.hpp 237: int x,y;
\CPP\LIB\TSWIN\tswin.hpp 238: };
\CPP\LIB\TSWIN\tswin.hpp 239: 
\CPP\LIB\TSWIN\tswin.hpp 240: extern const char *DOUBLE_BORDER;
\CPP\LIB\TSWIN\tswin.hpp 241: extern const char *SINGLE_BORDER;
\CPP\LIB\TSWIN\tswin.hpp 242: extern const char *BLOCK_BORDER;
\CPP\LIB\TSWIN\tswin.hpp 243: extern const char *CHISEL_BORDER;
\CPP\LIB\TSWIN\tswin.hpp 244: extern const char *RECESS_BORDER;
\CPP\LIB\TSWIN\tswin.hpp 245: 
\CPP\LIB\TSWIN\tswin.hpp 246: extern "C"
\CPP\LIB\TSWIN\tswin.hpp 247: {   
\CPP\LIB\TSWIN\tswin.hpp 248: void     tsw_mputc      (int x,int y,char c);
\CPP\LIB\TSWIN\tswin.hpp 249: void     tsw_maputc     (int x,int y,ATTR attr,char c);
\CPP\LIB\TSWIN\tswin.hpp 250: void     tsw_wait20ms   ();
\CPP\LIB\TSWIN\tswin.hpp 251: char     tsw_whaton     (int,int);
\CPP\LIB\TSWIN\tswin.hpp 252: void     tsw_changeatt  (ATTR attr,int x1,int y1,int x2,int y2);
\CPP\LIB\TSWIN\tswin.hpp 253: void     tsw_scroll     (char mode,char x1,char y1,char x2,char y2,char lines,ATTR attr);
\CPP\LIB\TSWIN\tswin.hpp 254: void     tsw_fillrect   (int x1,int y1,int x2,int y2,char c,ATTR attr);
\CPP\LIB\TSWIN\tswin.hpp 255: void     tsw_maputs     (int x,int y,ATTR attr,char *s);
\CPP\LIB\TSWIN\tswin.hpp 256: void     tsw_mputs      (int x,int y,char *s);
\CPP\LIB\TSWIN\tswin.hpp 257: void     tsw_gettext    (word *,int x1,int y1,int x2,int y2);
\CPP\LIB\TSWIN\tswin.hpp 258: void     tsw_puttext    (word *,int x1,int y1,int x2,int y2);
\CPP\LIB\TSWIN\tswin.hpp 259: int      tsw_printerstat(int printer=0);
\CPP\LIB\TSWIN\tswin.hpp 260: void     tsw_gotoxy     (int,int);
\CPP\LIB\TSWIN\tswin.hpp 261: 
\CPP\LIB\TSWIN\tswin.hpp 262: int      check_key();
\CPP\LIB\TSWIN\tswin.hpp 263: void     slide(void __far *);
\CPP\LIB\TSWIN\tswin.hpp 264: }
\CPP\LIB\TSWIN\tswin.hpp 265: 
\CPP\LIB\TSWIN\tswin.hpp 266: void     tsw_cursoron   ();
\CPP\LIB\TSWIN\tswin.hpp 267: void     tsw_cursoroff  ();
\CPP\LIB\TSWIN\tswin.hpp 268: 
\CPP\LIB\TSWIN\tswin.hpp 269: 
\CPP\LIB\TSWIN\tswin.hpp 270: void tsw_beep           (word freq=1000,word dur=100);
\CPP\LIB\TSWIN\tswin.hpp 271: char tsw_choice         (char *list);
\CPP\LIB\TSWIN\tswin.hpp 272: void tsw_errorattr      (ATTR,ATTR);
\CPP\LIB\TSWIN\tswin.hpp 273: void tsw_fatalerror     (char *string,ATTR attr = 0,ATTR tattr = 0);
\CPP\LIB\TSWIN\tswin.hpp 274: void tsw_nonfatalerror  (char *string,ATTR attr = 0,ATTR tattr = 0);
\CPP\LIB\TSWIN\tswin.hpp 275: void tsw_prependbs      (char *string);
\CPP\LIB\TSWIN\tswin.hpp 276: int  tsw_checkdisk      (int);
\CPP\LIB\TSWIN\tswin.hpp 277: void tsw_centerline     (int line,char *str,ATTR attr = 0);
\CPP\LIB\TSWIN\tswin.hpp 278: void tsw_drawbox        (int x1,int y1,int x2,int y2,const char *border,ATTR);
\CPP\LIB\TSWIN\tswin.hpp 279: void tsw_chiselbox      (int x1,int y1,int x2,int y2,const char *border,ATTR,ATTR);
\CPP\LIB\TSWIN\tswin.hpp 280: void tsw_recessbox      (int x1,int y1,int x2,int y2,const char *border,ATTR,ATTR,ATTR,ATTR);
\CPP\LIB\TSWIN\tswin.hpp 281: void tsw_showfooter     (char *string,ATTR attr=0x70, ATTR high=0);
\CPP\LIB\TSWIN\tswin.hpp 282: void tsw_clearfooter    ( ATTR attr=0x07 );
\CPP\LIB\TSWIN\tswin.hpp 283: void tsw_clearrect      (int x1,int y1,int x2,int y2,ATTR attr);
\CPP\LIB\TSWIN\tswin.hpp 284: void tsw_selbar         (int line,int x1,int x2,ATTR attr,int height=1);
\CPP\LIB\TSWIN\tswin.hpp 285: void tsw_fillscreen     (char c,ATTR attr);
\CPP\LIB\TSWIN\tswin.hpp 286: 
\CPP\LIB\TSWIN\tswin.hpp 287: void tsw_msgbox(byte attr, char *title , ... );
\CPP\LIB\TSWIN\tswin.hpp 288: 
\CPP\LIB\TSWIN\tswin.hpp 289: int  tsw_selbox( int    x,
\CPP\LIB\TSWIN\tswin.hpp 290: int    y,
\CPP\LIB\TSWIN\tswin.hpp 291: int    maxh,
\CPP\LIB\TSWIN\tswin.hpp 292: byte   attr,
\CPP\LIB\TSWIN\tswin.hpp 293: char **choices,
\CPP\LIB\TSWIN\tswin.hpp 294: int    mode,
\CPP\LIB\TSWIN\tswin.hpp 295: int    defChoice = 0,
\CPP\LIB\TSWIN\tswin.hpp 296: const char *border = DOUBLE_BORDER,
\CPP\LIB\TSWIN\tswin.hpp 297: ATTR  b_attr = 0,
\CPP\LIB\TSWIN\tswin.hpp 298: char *title  = 0,
\CPP\LIB\TSWIN\tswin.hpp 299: ATTR  t_attr = 0 );
\CPP\LIB\TSWIN\tswin.hpp 300: 
\CPP\LIB\TSWIN\tswin.hpp 301: class CursorState
\CPP\LIB\TSWIN\tswin.hpp 302: {
\CPP\LIB\TSWIN\tswin.hpp 303: bool prev;
\CPP\LIB\TSWIN\tswin.hpp 304: public:
\CPP\LIB\TSWIN\tswin.hpp 305: CursorState(bool mode)
\CPP\LIB\TSWIN\tswin.hpp 306: {
\CPP\LIB\TSWIN\tswin.hpp 307: prev = tsw_cursorstate;
\CPP\LIB\TSWIN\tswin.hpp 308: 
\CPP\LIB\TSWIN\tswin.hpp 309: if(mode)
\CPP\LIB\TSWIN\tswin.hpp 310: tsw_cursoron();
\CPP\LIB\TSWIN\tswin.hpp 311: else
\CPP\LIB\TSWIN\tswin.hpp 312: tsw_cursoroff();
\CPP\LIB\TSWIN\tswin.hpp 313: }
\CPP\LIB\TSWIN\tswin.hpp 314: ~CursorState()
\CPP\LIB\TSWIN\tswin.hpp 315: {
\CPP\LIB\TSWIN\tswin.hpp 316: if(prev)
\CPP\LIB\TSWIN\tswin.hpp 317: tsw_cursoron();
\CPP\LIB\TSWIN\tswin.hpp 318: else
\CPP\LIB\TSWIN\tswin.hpp 319: tsw_cursoroff();
\CPP\LIB\TSWIN\tswin.hpp 320: }
\CPP\LIB\TSWIN\tswin.hpp 321: };
\CPP\LIB\TSWIN\tswin.hpp 322: 
\CPP\LIB\TSWIN\tswin.hpp 323: class SaveBuffer
\CPP\LIB\TSWIN\tswin.hpp 324: {
\CPP\LIB\TSWIN\tswin.hpp 325: word *ptr;
\CPP\LIB\TSWIN\tswin.hpp 326: int   xs,ys;
\CPP\LIB\TSWIN\tswin.hpp 327: public:
\CPP\LIB\TSWIN\tswin.hpp 328: SaveBuffer  ();
\CPP\LIB\TSWIN\tswin.hpp 329: ~SaveBuffer ();
\CPP\LIB\TSWIN\tswin.hpp 330: void paste  (int x,int y);
\CPP\LIB\TSWIN\tswin.hpp 331: void paste  (int xf,int yf,int xt,int yt,int xsize,int ysize);
\CPP\LIB\TSWIN\tswin.hpp 332: void copy   (int x,int y,int xs,int ys);
\CPP\LIB\TSWIN\tswin.hpp 333: void clear  ();
\CPP\LIB\TSWIN\tswin.hpp 334: };
\CPP\LIB\TSWIN\tswin.hpp 335: 
\CPP\LIB\TSWIN\tswin.hpp 336: 
\CPP\LIB\TSWIN\tswin.hpp 337: 
\CPP\LIB\TSWIN\tswin.hpp 338: 
\CPP\LIB\TSWIN\tswin.hpp 339: 
\CPP\LIB\TSWIN\tswin.hpp 340: 
\CPP\LIB\TSWIN\tswin.hpp 341: 
\CPP\LIB\TSWIN\tswin.hpp 342: 
\CPP\LIB\TSWIN\tswin.hpp 343: 
\CPP\LIB\TSWIN\tswin.hpp 344: class Window
\CPP\LIB\TSWIN\tswin.hpp 345: {
\CPP\LIB\TSWIN\tswin.hpp 346: SaveBuffer buf;
\CPP\LIB\TSWIN\tswin.hpp 347: int curX,curY;
\CPP\LIB\TSWIN\tswin.hpp 348: int x1,y1,x2,y2;
\CPP\LIB\TSWIN\tswin.hpp 349: const char *borderType;
\CPP\LIB\TSWIN\tswin.hpp 350: int mode;
\CPP\LIB\TSWIN\tswin.hpp 351: char titleStr[81];
\CPP\LIB\TSWIN\tswin.hpp 352: int oldX[5],oldY[5];
\CPP\LIB\TSWIN\tswin.hpp 353: int sp;
\CPP\LIB\TSWIN\tswin.hpp 354: bool noCursorUpdate;
\CPP\LIB\TSWIN\tswin.hpp 355: 
\CPP\LIB\TSWIN\tswin.hpp 356: struct {
\CPP\LIB\TSWIN\tswin.hpp 357: byte status;
\CPP\LIB\TSWIN\tswin.hpp 358: byte needed;
\CPP\LIB\TSWIN\tswin.hpp 359: int  p[5];
\CPP\LIB\TSWIN\tswin.hpp 360: int  par;
\CPP\LIB\TSWIN\tswin.hpp 361: byte *rle_buf;
\CPP\LIB\TSWIN\tswin.hpp 362: } terminal;
\CPP\LIB\TSWIN\tswin.hpp 363: 
\CPP\LIB\TSWIN\tswin.hpp 364: int lowlevel_scanstring(char *str,unsigned len,byte mode,unsigned w);
\CPP\LIB\TSWIN\tswin.hpp 365: void (*initFunc)();
\CPP\LIB\TSWIN\tswin.hpp 366: void putShadow(int x1,int y1,int x2,int y2);
\CPP\LIB\TSWIN\tswin.hpp 367: void explode();
\CPP\LIB\TSWIN\tswin.hpp 368: void implode();
\CPP\LIB\TSWIN\tswin.hpp 369: void updateCursor();
\CPP\LIB\TSWIN\tswin.hpp 370: void _init();
\CPP\LIB\TSWIN\tswin.hpp 371: protected:
\CPP\LIB\TSWIN\tswin.hpp 372: KEY *scanHotKeys;
\CPP\LIB\TSWIN\tswin.hpp 373: ATTR fieldAttr;
\CPP\LIB\TSWIN\tswin.hpp 374: ATTR attr,t_attr,b_attr;
\CPP\LIB\TSWIN\tswin.hpp 375: ATTR tt_attr;
\CPP\LIB\TSWIN\tswin.hpp 376: ATTR iShadowColor;
\CPP\LIB\TSWIN\tswin.hpp 377: ATTR iOuterColor;
\CPP\LIB\TSWIN\tswin.hpp 378: public:
\CPP\LIB\TSWIN\tswin.hpp 379: KEY scanHotKey;
\CPP\LIB\TSWIN\tswin.hpp 380: int minX,minY,maxX,maxY;
\CPP\LIB\TSWIN\tswin.hpp 381: 
\CPP\LIB\TSWIN\tswin.hpp 382: void RecessBox( int x1,int y1,int x2,int y2,const char *border,ATTR,ATTR,ATTR,ATTR);
\CPP\LIB\TSWIN\tswin.hpp 383: 
\CPP\LIB\TSWIN\tswin.hpp 384: Window();
\CPP\LIB\TSWIN\tswin.hpp 385: Window(int x1,int y1,int x2,int y2,ATTR attr,int type=2,const char *border=DOUBLE_BORDER,ATTR b_attr=0,char *title=0,ATTR t_attr=0,ATTR o_attr=0, ATTR tt_attr=0);
\CPP\LIB\TSWIN\tswin.hpp 386: ~Window()  { close(); }
\CPP\LIB\TSWIN\tswin.hpp 387: void ShadowColor( ATTR iColor ) { iShadowColor = iColor; }
\CPP\LIB\TSWIN\tswin.hpp 388: void open( int x1,
\CPP\LIB\TSWIN\tswin.hpp 389: int y1,
\CPP\LIB\TSWIN\tswin.hpp 390: int x2,
\CPP\LIB\TSWIN\tswin.hpp 391: int y2,
\CPP\LIB\TSWIN\tswin.hpp 392: ATTR attr,
\CPP\LIB\TSWIN\tswin.hpp 393: int type = 2,
\CPP\LIB\TSWIN\tswin.hpp 394: const char *border = DOUBLE_BORDER,
\CPP\LIB\TSWIN\tswin.hpp 395: ATTR b_attr  = 0,
\CPP\LIB\TSWIN\tswin.hpp 396: char *title  = 0,
\CPP\LIB\TSWIN\tswin.hpp 397: ATTR t_attr  = 0, 
\CPP\LIB\TSWIN\tswin.hpp 398: ATTR tt_attr = 0);
\CPP\LIB\TSWIN\tswin.hpp 399: void open();
\CPP\LIB\TSWIN\tswin.hpp 400: void close();
\CPP\LIB\TSWIN\tswin.hpp 401: void initFunction(void(*f)())
\CPP\LIB\TSWIN\tswin.hpp 402: {
\CPP\LIB\TSWIN\tswin.hpp 403: initFunc = f;
\CPP\LIB\TSWIN\tswin.hpp 404: }
\CPP\LIB\TSWIN\tswin.hpp 405: void clear();
\CPP\LIB\TSWIN\tswin.hpp 406: void border(const char *type,ATTR attr=0);
\CPP\LIB\TSWIN\tswin.hpp 407: void border(ATTR attr);
\CPP\LIB\TSWIN\tswin.hpp 408: void moveCursor (int dx,int dy);
\CPP\LIB\TSWIN\tswin.hpp 409: void cursorUp   (int n = 1);
\CPP\LIB\TSWIN\tswin.hpp 410: void cursorDown (int n = 1);
\CPP\LIB\TSWIN\tswin.hpp 411: void cursorLeft (int n = 1);
\CPP\LIB\TSWIN\tswin.hpp 412: void cursorRight(int n = 1);
\CPP\LIB\TSWIN\tswin.hpp 413: void getPos(int& x,int& y)
\CPP\LIB\TSWIN\tswin.hpp 414: {
\CPP\LIB\TSWIN\tswin.hpp 415: x = curX;
\CPP\LIB\TSWIN\tswin.hpp 416: y = curY;
\CPP\LIB\TSWIN\tswin.hpp 417: }
\CPP\LIB\TSWIN\tswin.hpp 418: void setPos(int x,int y);
\CPP\LIB\TSWIN\tswin.hpp 419: int  getX()
\CPP\LIB\TSWIN\tswin.hpp 420: {
\CPP\LIB\TSWIN\tswin.hpp 421: return curX;
\CPP\LIB\TSWIN\tswin.hpp 422: }
\CPP\LIB\TSWIN\tswin.hpp 423: int  getY()
\CPP\LIB\TSWIN\tswin.hpp 424: {
\CPP\LIB\TSWIN\tswin.hpp 425: return curY;
\CPP\LIB\TSWIN\tswin.hpp 426: }
\CPP\LIB\TSWIN\tswin.hpp 427: void saveCursor();
\CPP\LIB\TSWIN\tswin.hpp 428: void restoreCursor();
\CPP\LIB\TSWIN\tswin.hpp 429: void attrib(ATTR a) { attr=a; }
\CPP\LIB\TSWIN\tswin.hpp 430: ATTR attrib() { return attr; }
\CPP\LIB\TSWIN\tswin.hpp 431: void scroll(byte direction=6,word numlines=1);
\CPP\LIB\TSWIN\tswin.hpp 432: void title(char *string,ATTR attr=0);
\CPP\LIB\TSWIN\tswin.hpp 433: void title(ATTR a);
\CPP\LIB\TSWIN\tswin.hpp 434: Window& operator<<(char *);
\CPP\LIB\TSWIN\tswin.hpp 435: Window& operator<<(char);
\CPP\LIB\TSWIN\tswin.hpp 436: void direct(int x,int y,ATTR a,char *str);
\CPP\LIB\TSWIN\tswin.hpp 437: void direct(int x,int y,char *str);
\CPP\LIB\TSWIN\tswin.hpp 438: void direct(int x,int y,char c);
\CPP\LIB\TSWIN\tswin.hpp 439: void direct(int x,int y,ATTR a,char c);
\CPP\LIB\TSWIN\tswin.hpp 440: void centerLine(int y,char *s,ATTR a=0);
\CPP\LIB\TSWIN\tswin.hpp 441: char whaton(int x,int y);
\CPP\LIB\TSWIN\tswin.hpp 442: int  scan(char *s,unsigned len,unsigned w=0,byte mode=0);
\CPP\LIB\TSWIN\tswin.hpp 443: int  scan(int& s,unsigned len,unsigned w=0,byte mode=0);
\CPP\LIB\TSWIN\tswin.hpp 444: int  scan(unsigned& s,unsigned len,unsigned w=0,byte mode=0);
\CPP\LIB\TSWIN\tswin.hpp 445: int  scan(long& s,unsigned len,unsigned w=0,byte mode=0);
\CPP\LIB\TSWIN\tswin.hpp 446: int  scan(Date& d,char *fmt);
\CPP\LIB\TSWIN\tswin.hpp 447: void setScanHotKeys(KEY *h = 0)
\CPP\LIB\TSWIN\tswin.hpp 448: {
\CPP\LIB\TSWIN\tswin.hpp 449: scanHotKeys = h;
\CPP\LIB\TSWIN\tswin.hpp 450: }
\CPP\LIB\TSWIN\tswin.hpp 451: KEY  getScanHotkey()
\CPP\LIB\TSWIN\tswin.hpp 452: {
\CPP\LIB\TSWIN\tswin.hpp 453: return scanHotKey;
\CPP\LIB\TSWIN\tswin.hpp 454: }
\CPP\LIB\TSWIN\tswin.hpp 455: void zoom();
\CPP\LIB\TSWIN\tswin.hpp 456: void change(int x1,int y1,int x2,int y2);
\CPP\LIB\TSWIN\tswin.hpp 457: void frame();
\CPP\LIB\TSWIN\tswin.hpp 458: void setFieldAttr(ATTR a)
\CPP\LIB\TSWIN\tswin.hpp 459: {
\CPP\LIB\TSWIN\tswin.hpp 460: fieldAttr = a;
\CPP\LIB\TSWIN\tswin.hpp 461: }
\CPP\LIB\TSWIN\tswin.hpp 462: void gauge(int x,int y,ATTR a,int len,dword val,dword max ,bool rewrite = TRUE);
\CPP\LIB\TSWIN\tswin.hpp 463: void gauge(int x,int y,int len,dword val,dword max ,bool rewrite = TRUE)
\CPP\LIB\TSWIN\tswin.hpp 464: {
\CPP\LIB\TSWIN\tswin.hpp 465: gauge(x,y,attr,len,val,max ,rewrite);
\CPP\LIB\TSWIN\tswin.hpp 466: }
\CPP\LIB\TSWIN\tswin.hpp 467: bool inEscape()
\CPP\LIB\TSWIN\tswin.hpp 468: {
\CPP\LIB\TSWIN\tswin.hpp 469: return bool(terminal.status != 0);
\CPP\LIB\TSWIN\tswin.hpp 470: }
\CPP\LIB\TSWIN\tswin.hpp 471: void disableCursor()
\CPP\LIB\TSWIN\tswin.hpp 472: {
\CPP\LIB\TSWIN\tswin.hpp 473: noCursorUpdate = TRUE;
\CPP\LIB\TSWIN\tswin.hpp 474: }
\CPP\LIB\TSWIN\tswin.hpp 475: void enableCursor()
\CPP\LIB\TSWIN\tswin.hpp 476: {
\CPP\LIB\TSWIN\tswin.hpp 477: noCursorUpdate = FALSE;
\CPP\LIB\TSWIN\tswin.hpp 478: updateCursor();
\CPP\LIB\TSWIN\tswin.hpp 479: }
\CPP\LIB\TSWIN\tswin.hpp 480: void placeCursor();
\CPP\LIB\TSWIN\tswin.hpp 481: int  selBox(char **choices,byte battr = 0x70,int defChoice = 0);
\CPP\LIB\TSWIN\tswin.hpp 482: };
\CPP\LIB\TSWIN\tswin.hpp 483: 
\CPP\LIB\TSWIN\tswin.hpp 484: 
\CPP\LIB\TSWIN\tswin.hpp 485: class FormWindow : public Window
\CPP\LIB\TSWIN\tswin.hpp 486: {
\CPP\LIB\TSWIN\tswin.hpp 487: Field *f;
\CPP\LIB\TSWIN\tswin.hpp 488: int    numFields;
\CPP\LIB\TSWIN\tswin.hpp 489: ATTR   dispAttr;
\CPP\LIB\TSWIN\tswin.hpp 490: ATTR   selAttr;
\CPP\LIB\TSWIN\tswin.hpp 491: KEY   *hotkeys;
\CPP\LIB\TSWIN\tswin.hpp 492: void   (*helpFunc)(int);
\CPP\LIB\TSWIN\tswin.hpp 493: int    cur_field;
\CPP\LIB\TSWIN\tswin.hpp 494: 
\CPP\LIB\TSWIN\tswin.hpp 495: int  editField(int);
\CPP\LIB\TSWIN\tswin.hpp 496: public:
\CPP\LIB\TSWIN\tswin.hpp 497: void showField(int);
\CPP\LIB\TSWIN\tswin.hpp 498: FormWindow();
\CPP\LIB\TSWIN\tswin.hpp 499: FormWindow(int x1,int y1,int x2,int y2,ATTR attr,int type=2,const char *border=DOUBLE_BORDER,ATTR b_attr=0,char *title=0,ATTR t_attr=0);
\CPP\LIB\TSWIN\tswin.hpp 500: FormWindow(Field *,int num_forms,ATTR disp_attr=0,ATTR sel_attr=0x70,KEY *hotkeys=0,void(*func)(int)=0);
\CPP\LIB\TSWIN\tswin.hpp 501: void define(Field *,int num_forms,ATTR disp_attr=0,ATTR sel_attr=0x70,KEY *hotkeys=0,void(*func)(int)=0);
\CPP\LIB\TSWIN\tswin.hpp 502: int process();
\CPP\LIB\TSWIN\tswin.hpp 503: void setField(int field=0)
\CPP\LIB\TSWIN\tswin.hpp 504: {
\CPP\LIB\TSWIN\tswin.hpp 505: cur_field = field;
\CPP\LIB\TSWIN\tswin.hpp 506: }
\CPP\LIB\TSWIN\tswin.hpp 507: 
\CPP\LIB\TSWIN\tswin.hpp 508: int getField()
\CPP\LIB\TSWIN\tswin.hpp 509: {
\CPP\LIB\TSWIN\tswin.hpp 510: return(cur_field);
\CPP\LIB\TSWIN\tswin.hpp 511: }
\CPP\LIB\TSWIN\tswin.hpp 512: };
\CPP\LIB\TSWIN\tswin.hpp 513: 
\CPP\LIB\TSWIN\tswin.hpp 514: 
\CPP\LIB\TSWIN\tswin.hpp 515: class EditWindow : public Window
\CPP\LIB\TSWIN\tswin.hpp 516: {
\CPP\LIB\TSWIN\tswin.hpp 517: int ed_x,ed_y;       
\CPP\LIB\TSWIN\tswin.hpp 518: int ed_x1,ed_y1;     
\CPP\LIB\TSWIN\tswin.hpp 519: int numlines;        
\CPP\LIB\TSWIN\tswin.hpp 520: String *line;        
\CPP\LIB\TSWIN\tswin.hpp 521: 
\CPP\LIB\TSWIN\tswin.hpp 522: void display(int line);
\CPP\LIB\TSWIN\tswin.hpp 523: void display();
\CPP\LIB\TSWIN\tswin.hpp 524: void display_cursor();
\CPP\LIB\TSWIN\tswin.hpp 525: void key_up();
\CPP\LIB\TSWIN\tswin.hpp 526: void key_down();
\CPP\LIB\TSWIN\tswin.hpp 527: void key_left();
\CPP\LIB\TSWIN\tswin.hpp 528: void key_right();
\CPP\LIB\TSWIN\tswin.hpp 529: void key_pageup();
\CPP\LIB\TSWIN\tswin.hpp 530: void key_pagedown();
\CPP\LIB\TSWIN\tswin.hpp 531: void key_del();
\CPP\LIB\TSWIN\tswin.hpp 532: void key_enter();
\CPP\LIB\TSWIN\tswin.hpp 533: void key_end();
\CPP\LIB\TSWIN\tswin.hpp 534: void key_home();
\CPP\LIB\TSWIN\tswin.hpp 535: void key_bs();
\CPP\LIB\TSWIN\tswin.hpp 536: void key_char(char k);
\CPP\LIB\TSWIN\tswin.hpp 537: public:
\CPP\LIB\TSWIN\tswin.hpp 538: EditWindow();
\CPP\LIB\TSWIN\tswin.hpp 539: ~EditWindow();
\CPP\LIB\TSWIN\tswin.hpp 540: void feed(char *text);
\CPP\LIB\TSWIN\tswin.hpp 541: KEY  edit(KEY *hotkeys=0);
\CPP\LIB\TSWIN\tswin.hpp 542: void retrieve(char *text,int maxsize=0);
\CPP\LIB\TSWIN\tswin.hpp 543: };
\CPP\LIB\TSWIN\tswin.hpp 544: 
\CPP\LIB\TSWIN\tswin.hpp 545: class ViewWindow : public Window
\CPP\LIB\TSWIN\tswin.hpp 546: {
\CPP\LIB\TSWIN\tswin.hpp 547: int start,end;
\CPP\LIB\TSWIN\tswin.hpp 548: KEY *hotkeys;
\CPP\LIB\TSWIN\tswin.hpp 549: void (*func)(int i,int x,int y);
\CPP\LIB\TSWIN\tswin.hpp 550: int num_entries;
\CPP\LIB\TSWIN\tswin.hpp 551: public:
\CPP\LIB\TSWIN\tswin.hpp 552: KEY hotkey;
\CPP\LIB\TSWIN\tswin.hpp 553: 
\CPP\LIB\TSWIN\tswin.hpp 554: ViewWindow() { }
\CPP\LIB\TSWIN\tswin.hpp 555: ViewWindow(int num,void(*function)(int,int,int),KEY *hot);
\CPP\LIB\TSWIN\tswin.hpp 556: void define(int num,void(*function)(int,int,int),KEY *hot);
\CPP\LIB\TSWIN\tswin.hpp 557: int process();
\CPP\LIB\TSWIN\tswin.hpp 558: void showlast();
\CPP\LIB\TSWIN\tswin.hpp 559: void showfirst() { end=0; }
\CPP\LIB\TSWIN\tswin.hpp 560: };
\CPP\LIB\TSWIN\tswin.hpp 561: 
\CPP\LIB\TSWIN\tswin.hpp 562: class SelectWindow : public Window
\CPP\LIB\TSWIN\tswin.hpp 563: {
\CPP\LIB\TSWIN\tswin.hpp 564: int start,end;
\CPP\LIB\TSWIN\tswin.hpp 565: KEY *hotkeys;
\CPP\LIB\TSWIN\tswin.hpp 566: void (*func)(int,int,int);
\CPP\LIB\TSWIN\tswin.hpp 567: void (*emptyfunc)(int,int);
\CPP\LIB\TSWIN\tswin.hpp 568: void (*action)(int);
\CPP\LIB\TSWIN\tswin.hpp 569: char *selected;
\CPP\LIB\TSWIN\tswin.hpp 570: ATTR selAttr,bar_attr;
\CPP\LIB\TSWIN\tswin.hpp 571: int num_entries;
\CPP\LIB\TSWIN\tswin.hpp 572: public:
\CPP\LIB\TSWIN\tswin.hpp 573: int current;
\CPP\LIB\TSWIN\tswin.hpp 574: KEY hotkey;
\CPP\LIB\TSWIN\tswin.hpp 575: 
\CPP\LIB\TSWIN\tswin.hpp 576: SelectWindow() { }
\CPP\LIB\TSWIN\tswin.hpp 577: 
\CPP\LIB\TSWIN\tswin.hpp 578: SelectWindow( int  num,
\CPP\LIB\TSWIN\tswin.hpp 579: ATTR battr,
\CPP\LIB\TSWIN\tswin.hpp 580: void(*f)(int,int,int),
\CPP\LIB\TSWIN\tswin.hpp 581: ATTR  sattr = 0,
\CPP\LIB\TSWIN\tswin.hpp 582: char *sel   = 0,
\CPP\LIB\TSWIN\tswin.hpp 583: KEY  *hot   = 0,
\CPP\LIB\TSWIN\tswin.hpp 584: void(*actionf)(int) = 0,
\CPP\LIB\TSWIN\tswin.hpp 585: void(*emptyfunc)(int,int) = 0 );
\CPP\LIB\TSWIN\tswin.hpp 586: 
\CPP\LIB\TSWIN\tswin.hpp 587: void define( int  num,
\CPP\LIB\TSWIN\tswin.hpp 588: ATTR battr,
\CPP\LIB\TSWIN\tswin.hpp 589: void(*f)(int,int,int),
\CPP\LIB\TSWIN\tswin.hpp 590: ATTR  sattr = 0,
\CPP\LIB\TSWIN\tswin.hpp 591: char *sel   = 0,
\CPP\LIB\TSWIN\tswin.hpp 592: KEY *hot    = 0,
\CPP\LIB\TSWIN\tswin.hpp 593: void(*actionf)(int)       = 0,
\CPP\LIB\TSWIN\tswin.hpp 594: void(*emptyfunc)(int,int) = 0 );
\CPP\LIB\TSWIN\tswin.hpp 595: void redefine(int num);
\CPP\LIB\TSWIN\tswin.hpp 596: int process();
\CPP\LIB\TSWIN\tswin.hpp 597: void show(int n);
\CPP\LIB\TSWIN\tswin.hpp 598: void showlast()  { show(num_entries-1); }
\CPP\LIB\TSWIN\tswin.hpp 599: void showfirst() { show(0); }
\CPP\LIB\TSWIN\tswin.hpp 600: };
\CPP\LIB\TSWIN\tswin.hpp 601: 
\CPP\LIB\TSWIN\tswin.hpp 602: struct menu_item
\CPP\LIB\TSWIN\tswin.hpp 603: {
\CPP\LIB\TSWIN\tswin.hpp 604: KEY   hotkey;
\CPP\LIB\TSWIN\tswin.hpp 605: int   highlight1,highlight2;
\CPP\LIB\TSWIN\tswin.hpp 606: char *s;
\CPP\LIB\TSWIN\tswin.hpp 607: };
\CPP\LIB\TSWIN\tswin.hpp 608: 
\CPP\LIB\TSWIN\tswin.hpp 609: class PopMenu : public Window
\CPP\LIB\TSWIN\tswin.hpp 610: {
\CPP\LIB\TSWIN\tswin.hpp 611: int current;
\CPP\LIB\TSWIN\tswin.hpp 612: menu_item *items;
\CPP\LIB\TSWIN\tswin.hpp 613: KEY *hotkeys;
\CPP\LIB\TSWIN\tswin.hpp 614: ATTR bar_attr,high_attr;
\CPP\LIB\TSWIN\tswin.hpp 615: int num_entries;
\CPP\LIB\TSWIN\tswin.hpp 616: void (*action)(int);
\CPP\LIB\TSWIN\tswin.hpp 617: public:
\CPP\LIB\TSWIN\tswin.hpp 618: KEY hotkey;
\CPP\LIB\TSWIN\tswin.hpp 619: 
\CPP\LIB\TSWIN\tswin.hpp 620: PopMenu();
\CPP\LIB\TSWIN\tswin.hpp 621: PopMenu(menu_item *i,ATTR b_attr=0x70,ATTR h_attr=0x70,KEY *hot=0,void (*func)(int)=0);
\CPP\LIB\TSWIN\tswin.hpp 622: void define(menu_item *i,ATTR b_attr=0x70,ATTR h_attr=0x70,KEY *hot=0,void (*func)(int)=0);
\CPP\LIB\TSWIN\tswin.hpp 623: int process();
\CPP\LIB\TSWIN\tswin.hpp 624: void refresh(int n=1);
\CPP\LIB\TSWIN\tswin.hpp 625: };
\CPP\LIB\TSWIN\tswin.hpp 626: 
\CPP\LIB\TSWIN\tswin.hpp 627: class KeyBoard
\CPP\LIB\TSWIN\tswin.hpp 628: {
\CPP\LIB\TSWIN\tswin.hpp 629: KEY last;
\CPP\LIB\TSWIN\tswin.hpp 630: KEY pushed;
\CPP\LIB\TSWIN\tswin.hpp 631: void (*help)();
\CPP\LIB\TSWIN\tswin.hpp 632: public:
\CPP\LIB\TSWIN\tswin.hpp 633: KeyBoard();
\CPP\LIB\TSWIN\tswin.hpp 634: ~KeyBoard()
\CPP\LIB\TSWIN\tswin.hpp 635: {
\CPP\LIB\TSWIN\tswin.hpp 636: tsw_cursoron();
\CPP\LIB\TSWIN\tswin.hpp 637: }
\CPP\LIB\TSWIN\tswin.hpp 638: void push(KEY k)
\CPP\LIB\TSWIN\tswin.hpp 639: {
\CPP\LIB\TSWIN\tswin.hpp 640: pushed = k;
\CPP\LIB\TSWIN\tswin.hpp 641: }
\CPP\LIB\TSWIN\tswin.hpp 642: KEY get();
\CPP\LIB\TSWIN\tswin.hpp 643: void get(KEY& k)
\CPP\LIB\TSWIN\tswin.hpp 644: {
\CPP\LIB\TSWIN\tswin.hpp 645: k = get();
\CPP\LIB\TSWIN\tswin.hpp 646: }
\CPP\LIB\TSWIN\tswin.hpp 647: KEY uget();
\CPP\LIB\TSWIN\tswin.hpp 648: void uget(KEY& k)
\CPP\LIB\TSWIN\tswin.hpp 649: {
\CPP\LIB\TSWIN\tswin.hpp 650: k = uget();
\CPP\LIB\TSWIN\tswin.hpp 651: }
\CPP\LIB\TSWIN\tswin.hpp 652: void getlast(KEY& c)
\CPP\LIB\TSWIN\tswin.hpp 653: {
\CPP\LIB\TSWIN\tswin.hpp 654: c = last;
\CPP\LIB\TSWIN\tswin.hpp 655: }
\CPP\LIB\TSWIN\tswin.hpp 656: KEY getlast()
\CPP\LIB\TSWIN\tswin.hpp 657: {
\CPP\LIB\TSWIN\tswin.hpp 658: return last;
\CPP\LIB\TSWIN\tswin.hpp 659: }
\CPP\LIB\TSWIN\tswin.hpp 660: bool hit();
\CPP\LIB\TSWIN\tswin.hpp 661: void clear();
\CPP\LIB\TSWIN\tswin.hpp 662: char choice(const char *s);
\CPP\LIB\TSWIN\tswin.hpp 663: bool ask();
\CPP\LIB\TSWIN\tswin.hpp 664: void helpfunc(void(*helpfunc)())
\CPP\LIB\TSWIN\tswin.hpp 665: {
\CPP\LIB\TSWIN\tswin.hpp 666: help = helpfunc;
\CPP\LIB\TSWIN\tswin.hpp 667: }
\CPP\LIB\TSWIN\tswin.hpp 668: };
\CPP\LIB\TSWIN\tswin.hpp 669: 
\CPP\LIB\TSWIN\tswin.hpp 670: class ScreenRestore
\CPP\LIB\TSWIN\tswin.hpp 671: {
\CPP\LIB\TSWIN\tswin.hpp 672: word *buffer;
\CPP\LIB\TSWIN\tswin.hpp 673: word pos;
\CPP\LIB\TSWIN\tswin.hpp 674: byte mode;
\CPP\LIB\TSWIN\tswin.hpp 675: public:
\CPP\LIB\TSWIN\tswin.hpp 676: ScreenRestore(int mode=0);
\CPP\LIB\TSWIN\tswin.hpp 677: ~ScreenRestore();
\CPP\LIB\TSWIN\tswin.hpp 678: };
\CPP\LIB\TSWIN\tswin.hpp 679: 
\CPP\LIB\TSWIN\tswin.hpp 680: extern Window SCREEN; 
\CPP\LIB\TSWIN\tswin.hpp 681: extern KeyBoard KB;   
\CPP\LIB\TSWIN\tswin.hpp 682: 
\CPP\LIB\TSWIN\tswin.hpp 683: 
\CPP\LIB\TSWIN\tswin.hpp 684: 
\CPP\LIB\TSWIN\tswin.hpp 685: 
\CPP\LIB\TSWIN\tswin.hpp 686: 
extsel.cpp 11: 
extsel.hpp 1: class ExtSelectWindow : public Window
extsel.hpp 2: {
extsel.hpp 3: int start,
extsel.hpp 4: end,
extsel.hpp 5: previous;
extsel.hpp 6: KEY *hotKeys;
extsel.hpp 7: int  (*func)(ExtSelectWindow&,int n,int y=0,int maxheight=0);
extsel.hpp 8: void (*action)(int);
extsel.hpp 9: ATTR barAttr;
extsel.hpp 10: int numEntries;
extsel.hpp 11: int offset[100];
extsel.hpp 12: 
extsel.hpp 13: void recalc(int order = 1);
extsel.hpp 14: void redraw(int = -1);
extsel.hpp 15: void scrollUp(int n);
extsel.hpp 16: void scrollDown(int n);
extsel.hpp 17: 
extsel.hpp 18: void keyDown();
extsel.hpp 19: void keyUp();
extsel.hpp 20: void keyPgUp();
extsel.hpp 21: void keyPgDn();
extsel.hpp 22: void keyHome();
extsel.hpp 23: void keyEnd();
extsel.hpp 24: 
extsel.hpp 25: public:
extsel.hpp 26: int current;
extsel.hpp 27: KEY hotkey;
extsel.hpp 28: 
extsel.hpp 29: ExtSelectWindow () { }
extsel.hpp 30: ExtSelectWindow (int num,ATTR battr,int (*f)(ExtSelectWindow&,int,int,int),KEY *hot=0,void(*actionf)(int)=0);
extsel.hpp 31: 
extsel.hpp 32: void define     (int num,ATTR battr,int (*f)(ExtSelectWindow&,int,int,int),KEY *hot=0,void(*actionf)(int)=0);
extsel.hpp 33: void reDefine   (int num);
extsel.hpp 34: 
extsel.hpp 35: int  process();
extsel.hpp 36: 
extsel.hpp 37: void show(int n);
extsel.hpp 38: void showLast()  { show(numEntries-1); }
extsel.hpp 39: void showFirst() { show(0); }
extsel.hpp 40: };
extsel.hpp 41: 
extsel.hpp 42: 
extsel.cpp 12: 
extsel.cpp 13: 
extsel.cpp 14: 
extsel.cpp 15: 
extsel.cpp 16: void
extsel.cpp 17: ExtSelectWindow::recalc(int order)
extsel.cpp 18: {
extsel.cpp 19: int i,y;
extsel.cpp 20: int height = maxY - minY + 1;
extsel.cpp 21: 
extsel.cpp 22: if(end >= numEntries)
extsel.cpp 23: {
extsel.cpp 24: end = numEntries-1;
extsel.cpp 25: 
extsel.cpp 26: for(i=1,y=height - (*func)(*this,end) ; y>0 ; i++)
extsel.cpp 27: {
extsel.cpp 28: y -= (*func)(*this,end-i);
extsel.cpp 29: }
extsel.cpp 30: 
extsel.cpp 31: start = end - i + 1;
extsel.cpp 32: 
extsel.cpp 33: for(i = start ; y < height; i++)
extsel.cpp 34: {
extsel.cpp 35: offset[i-start] = y;
extsel.cpp 36: 
extsel.cpp 37: y += (*func)(*this,i);
extsel.cpp 38: }
extsel.cpp 39: }
extsel.cpp 40: else
extsel.cpp 41: {
extsel.cpp 42: for(i = start , y = 0; y < height; i++)
extsel.cpp 43: {
extsel.cpp 44: if(i >= numEntries)
extsel.cpp 45: {
extsel.cpp 46: end = numEntries;
extsel.cpp 47: recalc();
extsel.cpp 48: return;
extsel.cpp 49: }
extsel.cpp 50: offset[i-start] = y;
extsel.cpp 51: 
extsel.cpp 52: y += (*func)(*this,i);
extsel.cpp 53: }
extsel.cpp 54: 
extsel.cpp 55: end = i-1;
extsel.cpp 56: }
extsel.cpp 57: }
extsel.cpp 58: 
extsel.cpp 59: void
extsel.cpp 60: ExtSelectWindow::scrollUp(int n)
extsel.cpp 61: {
extsel.cpp 62: end++;
extsel.cpp 63: 
extsel.cpp 64: int left = offset[0] + (*func)(*this,start);  
extsel.cpp 65: 
extsel.cpp 66: int new_offset = offset[0];
extsel.cpp 67: 
extsel.cpp 68: int i = n;
extsel.cpp 69: 
extsel.cpp 70: while( i >= left)
extsel.cpp 71: {
extsel.cpp 72: new_offset += (*func)(*this,start);
extsel.cpp 73: start++;
extsel.cpp 74: i -= (*func)(*this,start);
extsel.cpp 75: }
extsel.cpp 76: 
extsel.cpp 77: offset[0] = new_offset - n;
extsel.cpp 78: 
extsel.cpp 79: for(i = start+1 ; i <= end ; i++)
extsel.cpp 80: {
extsel.cpp 81: offset[i-start] = offset[i-start-1] + (*func)(*this,i-1);
extsel.cpp 82: }
extsel.cpp 83: }
extsel.cpp 84: 
extsel.cpp 85: void
extsel.cpp 86: ExtSelectWindow::scrollDown(int)
extsel.cpp 87: {
extsel.cpp 88: start--;
extsel.cpp 89: recalc();
extsel.cpp 90: }
extsel.cpp 91: 
extsel.cpp 92: 
extsel.cpp 93: void
extsel.cpp 94: ExtSelectWindow::redraw(int n)
extsel.cpp 95: {
extsel.cpp 96: if(n >= 0)
extsel.cpp 97: {
extsel.cpp 98: (*func)(*this,n,offset[n-start] + 1,maxY - minY - offset[n-start] + 1);
extsel.cpp 99: }
extsel.cpp 100: else
extsel.cpp 101: {
extsel.cpp 102: clear();
extsel.cpp 103: 
extsel.cpp 104: for(int i=start; i <= end ; i++)
extsel.cpp 105: {
extsel.cpp 106: (*func)(*this,i,offset[i-start] + 1,maxY - minY - offset[i-start] + 1);
extsel.cpp 107: }
extsel.cpp 108: }
extsel.cpp 109: }
extsel.cpp 110: 
extsel.cpp 111: void
extsel.cpp 112: ExtSelectWindow::keyDown()
extsel.cpp 113: {
extsel.cpp 114: if(current >= numEntries-1)
extsel.cpp 115: return;
extsel.cpp 116: 
extsel.cpp 117: previous = current++;
extsel.cpp 118: 
extsel.cpp 119: int height = (maxY-minY+1);
extsel.cpp 120: 
extsel.cpp 121: if(   current == end
extsel.cpp 122: && offset[end-start]+(*func)(*this,current) > height)
extsel.cpp 123: {
extsel.cpp 124: int n = offset[end-start] + (*func)(*this,current) - height;
extsel.cpp 125: 
extsel.cpp 126: tsw_scroll(6,minX,minY,maxX,maxY,n,attr);
extsel.cpp 127: 
extsel.cpp 128: scrollUp(n);
extsel.cpp 129: 
extsel.cpp 130: redraw(current);
extsel.cpp 131: }
extsel.cpp 132: 
extsel.cpp 133: if(current > end)
extsel.cpp 134: {
extsel.cpp 135: int n = (*func)(*this,current);
extsel.cpp 136: 
extsel.cpp 137: tsw_scroll(6,minX,minY,maxX,maxY,n,attr);
extsel.cpp 138: scrollUp(n);
extsel.cpp 139: 
extsel.cpp 140: redraw(current);
extsel.cpp 141: }
extsel.cpp 142: }
extsel.cpp 143: 
extsel.cpp 144: void
extsel.cpp 145: ExtSelectWindow::keyUp()
extsel.cpp 146: {
extsel.cpp 147: }
extsel.cpp 148: 
extsel.cpp 149: int
extsel.cpp 150: ExtSelectWindow::process()
extsel.cpp 151: {
extsel.cpp 152: previous = current;
extsel.cpp 153: 
extsel.cpp 154: if(!end)
extsel.cpp 155: {
extsel.cpp 156: recalc();
extsel.cpp 157: redraw();
extsel.cpp 158: }
extsel.cpp 159: 
extsel.cpp 160: 
extsel.cpp 161: for(;;)
extsel.cpp 162: {
extsel.cpp 163: int ofs;
extsel.cpp 164: 
extsel.cpp 165: if(previous >= start && previous <= end)
extsel.cpp 166: {
extsel.cpp 167: ofs = offset[previous-start];
extsel.cpp 168: tsw_selbar(( (ofs)>(0) ? (ofs) : (0) )+minY,minX,maxX,attr,(*func)(*this,previous)+((ofs < 0)?ofs:0));
extsel.cpp 169: redraw(previous);
extsel.cpp 170: }
extsel.cpp 171: 
extsel.cpp 172: ofs = offset[current-start];
extsel.cpp 173: 
extsel.cpp 174: tsw_selbar(( (ofs)>(0) ? (ofs) : (0) )+minY,minX,maxX,barAttr,(*func)(*this,current)+((ofs < 0) ? ofs:0));
extsel.cpp 175: 
extsel.cpp 176: 
extsel.cpp 177: if(action!=0 && numEntries) (*action)(current);
extsel.cpp 178: KB.clear();
extsel.cpp 179: KEY k = KB.uget();
extsel.cpp 180: 
extsel.cpp 181: if(hotKeys!=0)
extsel.cpp 182: for(int i=0 ; hotKeys[i] ; i++)
extsel.cpp 183: if(k == hotKeys[i])
extsel.cpp 184: {
extsel.cpp 185: hotkey = k;
extsel.cpp 186: return (-2);
extsel.cpp 187: }
extsel.cpp 188: 
extsel.cpp 189: if(k == KEY_ESC)
extsel.cpp 190: {
extsel.cpp 191: return (-1);
extsel.cpp 192: }
extsel.cpp 193: 
extsel.cpp 194: if(k == 13)
extsel.cpp 195: {
extsel.cpp 196: return current;
extsel.cpp 197: }
extsel.cpp 198: 
extsel.cpp 199: switch(k)
extsel.cpp 200: {
extsel.cpp 201: case KEY_DN: keyDown();
extsel.cpp 202: break;
extsel.cpp 203: case KEY_UP:
extsel.cpp 204: {
extsel.cpp 205: if(current <= 0)
extsel.cpp 206: break;
extsel.cpp 207: 
extsel.cpp 208: previous = current--;
extsel.cpp 209: 
extsel.cpp 210: if(current == start && offset[0] < 0)
extsel.cpp 211: {
extsel.cpp 212: tsw_scroll(7,minX,minY,maxX,maxY,-offset[0],attr);
extsel.cpp 213: recalc();
extsel.cpp 214: redraw(current);
extsel.cpp 215: }
extsel.cpp 216: 
extsel.cpp 217: if(current < start)
extsel.cpp 218: {
extsel.cpp 219: int n = (*func)(*this,current);
extsel.cpp 220: 
extsel.cpp 221: tsw_scroll(7,minX,minY,maxX,maxY,n,attr);
extsel.cpp 222: scrollDown(n);
extsel.cpp 223: 
extsel.cpp 224: redraw(current);
extsel.cpp 225: }
extsel.cpp 226: }
extsel.cpp 227: break;
extsel.cpp 228: 
extsel.cpp 229: case KEY_PGUP:
extsel.cpp 230: {
extsel.cpp 231: if(start == 0)
extsel.cpp 232: {
extsel.cpp 233: previous = current;
extsel.cpp 234: current = 0;
extsel.cpp 235: break;
extsel.cpp 236: }
extsel.cpp 237: 
extsel.cpp 238: int n = 0;
extsel.cpp 239: int y = offset[current-start];
extsel.cpp 240: 
extsel.cpp 241: for(int i = start;i>0 && n<(maxY-minY+1);i--)
extsel.cpp 242: {
extsel.cpp 243: n += (*func)(*this,i);
extsel.cpp 244: }
extsel.cpp 245: 
extsel.cpp 246: start = i;
extsel.cpp 247: recalc();
extsel.cpp 248: 
extsel.cpp 249: current = start;
extsel.cpp 250: 
extsel.cpp 251: for(i=start;i<=end;i++)
extsel.cpp 252: {
extsel.cpp 253: if(offset[i-start] >= y)
extsel.cpp 254: {
extsel.cpp 255: current = i;
extsel.cpp 256: break;
extsel.cpp 257: }
extsel.cpp 258: }
extsel.cpp 259: 
extsel.cpp 260: redraw();
extsel.cpp 261: }
extsel.cpp 262: break;
extsel.cpp 263: 
extsel.cpp 264: case KEY_PGDN:
extsel.cpp 265: {
extsel.cpp 266: if(end == numEntries-1)
extsel.cpp 267: {
extsel.cpp 268: previous = current;
extsel.cpp 269: current  = end;
extsel.cpp 270: break;
extsel.cpp 271: }
extsel.cpp 272: 
extsel.cpp 273: int y = offset[current-start];
extsel.cpp 274: 
extsel.cpp 275: start = end+1;
extsel.cpp 276: recalc();
extsel.cpp 277: 
extsel.cpp 278: previous = current;
extsel.cpp 279: current = start;
extsel.cpp 280: 
extsel.cpp 281: for(int i=start;i<=end;i++)
extsel.cpp 282: {
extsel.cpp 283: if(offset[i-start] >= y)
extsel.cpp 284: {
extsel.cpp 285: current = i;
extsel.cpp 286: break;
extsel.cpp 287: }
extsel.cpp 288: }
extsel.cpp 289: 
extsel.cpp 290: redraw();
extsel.cpp 291: }
extsel.cpp 292: break;
extsel.cpp 293: 
extsel.cpp 294: case KEY_HOME:
extsel.cpp 295: {
extsel.cpp 296: start = 0;
extsel.cpp 297: current = previous = 0;
extsel.cpp 298: recalc();
extsel.cpp 299: redraw();
extsel.cpp 300: }
extsel.cpp 301: break;
extsel.cpp 302: 
extsel.cpp 303: case KEY_END:
extsel.cpp 304: {
extsel.cpp 305: if(current == numEntries-1)
extsel.cpp 306: break;
extsel.cpp 307: 
extsel.cpp 308: 
extsel.cpp 309: end = numEntries;
extsel.cpp 310: current = numEntries-1;
extsel.cpp 311: recalc();
extsel.cpp 312: redraw();
extsel.cpp 313: }
extsel.cpp 314: break;
extsel.cpp 315: }
extsel.cpp 316: }
extsel.cpp 317: }
extsel.cpp 318: 
extsel.cpp 319: void
extsel.cpp 320: ExtSelectWindow::show(int n)
extsel.cpp 321: {
extsel.cpp 322: start = n;
extsel.cpp 323: current = previous = n;
extsel.cpp 324: recalc();
extsel.cpp 325: redraw();
extsel.cpp 326: }
extsel.cpp 327: 
extsel.cpp 328: ExtSelectWindow::ExtSelectWindow(int num,ATTR battr,int(*f)(ExtSelectWindow&,int,int,int),KEY *hot,void(*actionf)(int))
extsel.cpp 329: {
extsel.cpp 330: barAttr    = battr;
extsel.cpp 331: numEntries = num;
extsel.cpp 332: hotKeys    = hot;
extsel.cpp 333: func       = f;
extsel.cpp 334: action     = actionf;
extsel.cpp 335: 
extsel.cpp 336: current    = 0;
extsel.cpp 337: previous   = 0;
extsel.cpp 338: start      = 0;
extsel.cpp 339: end        = 0;
extsel.cpp 340: }
extsel.cpp 341: 
extsel.cpp 342: void
extsel.cpp 343: ExtSelectWindow::define(int num,ATTR battr,int(*f)(ExtSelectWindow&,int,int,int),KEY *hot,void(*actionf)(int))
extsel.cpp 344: {
extsel.cpp 345: barAttr    = battr;
extsel.cpp 346: numEntries = num;
extsel.cpp 347: hotKeys    = hot;
extsel.cpp 348: func       = f;
extsel.cpp 349: action     = actionf;
extsel.cpp 350: 
extsel.cpp 351: current    = 0;
extsel.cpp 352: previous   = 0;
extsel.cpp 353: start      = 0;
extsel.cpp 354: end        = 0;
extsel.cpp 355: }
extsel.cpp 356: 
extsel.cpp 357: void
extsel.cpp 358: ExtSelectWindow::reDefine(int num)
extsel.cpp 359: {
extsel.cpp 360: }
extsel.cpp 361: 
extsel.cpp 362: 